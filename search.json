[{"path":"https://fspecque.github.io/test/LICENSE.html","id":null,"dir":"","previous_headings":"","what":"MIT License","title":"MIT License","text":"Copyright (c) 2024 Centre de Bioinformatique de Bordeaux (CBiB) Permission hereby granted, free charge, person obtaining copy software associated documentation files (“Software”), deal Software without restriction, including without limitation rights use, copy, modify, merge, publish, distribute, sublicense, /sell copies Software, permit persons Software furnished , subject following conditions: copyright notice permission notice shall included copies substantial portions Software. SOFTWARE PROVIDED “”, WITHOUT WARRANTY KIND, EXPRESS IMPLIED, INCLUDING LIMITED WARRANTIES MERCHANTABILITY, FITNESS PARTICULAR PURPOSE NONINFRINGEMENT. EVENT SHALL AUTHORS COPYRIGHT HOLDERS LIABLE CLAIM, DAMAGES LIABILITY, WHETHER ACTION CONTRACT, TORT OTHERWISE, ARISING , CONNECTION SOFTWARE USE DEALINGS SOFTWARE.","code":""},{"path":"https://fspecque.github.io/test/articles/SeuratIntegrate.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"Introduction to SeuratIntegrate","text":"SeuratIntegrate R package aims extend pool single-cell RNA sequencing (scRNA-seq) integration methods available Seurat. Moreover, SeuratIntegrate provides set tools evaluate performance integrations produced.","code":""},{"path":"https://fspecque.github.io/test/articles/SeuratIntegrate.html","id":"integrations","dir":"Articles","previous_headings":"Introduction","what":"Integrations","title":"Introduction to SeuratIntegrate","text":"SeuratIntegrate provides access R Python methods correct batch effect: Comprehensive overview integration methods provided SeuratIntegrate SeuratIntegrate provides new interface integrate layers object: DoIntegrate(). Moreover, SeuratIntegrate compatible CCA RPCA (included Seurat) FastMNN (SeuratWrappers)","code":""},{"path":"https://fspecque.github.io/test/articles/SeuratIntegrate.html","id":"scoring","dir":"Articles","previous_headings":"Introduction","what":"Scoring","title":"Introduction to SeuratIntegrate","text":"SeuratIntegrate incorporates 11 scoring metrics: 6 quantify degree batch mixing  (batch correction), 5 assess preservation biological differences  (bio-conservation) based ground truth cell type labels. table summarising score’s input type: Table summarising inputs required score, type scores belongs . scores computed embedding  (Seurat::DimReduc object) graph  (Seurat::Neighbor Seurat::Graph object). exceptions ARI NMI, compare two categorical variables thus don’t need anything else cell-type cluster assignment variables.d anything else cell-type cluster assignment variables. scores based cell type label variable. consists estimate cell’s type obtained analysing batch separately using automatic cell annotation algorithm. estimate cell types must sufficient quality considered suitable ground truth.","code":""},{"path":"https://fspecque.github.io/test/articles/SeuratIntegrate.html","id":"setup","dir":"Articles","previous_headings":"","what":"Setup","title":"Introduction to SeuratIntegrate","text":"use small dataset 200 immune liver cells around 6,500 genes included SeuratIntegrate. comprises 4 donors 2 studies. Among donors, 2 healthy 2 suffering hepatocellular carcinoma (HCC). Importantly, Seurat object’s metadata also embeds cell type annotation variables. Note albeit compulsory, high quality cell-type annotation important evaluate performance integrations many scoring metrics use ground truth. Moreover, helps verifying whether technical effects (usually called batch effects) overweight true biological differences. , use last one save : going test 3 integration methods output different types objects. use ComBat (corrected counts), BBKNN (corrected knn graph) Harmony (corrected dimension reduction). BBKNN Python method, need conda environment able use . Right now, don’t environment:  Hopefully, SeuratIntegrate facilitates task UpdateEnvCache(): Note: Similarly, can call UpdateEnvCache() Python methods (“scvi”, “scanorama”, “trVAE”) set corresponding conda environments. process successful, cache conda environments updated:  also want make sure conda environment umap-learn version compatible Seurat:","code":"library(SeuratIntegrate) data(\"liver_small\") dim(liver_small)  # genes x cells ## [1] 6534  200 liver_small[[]][,c(13, 15:17)] cell.var <- \"manual_cell_type_short\" getCache() UpdateEnvCache(\"bbknn\") getCache() reticulate::conda_create('umap_0.5.4', packages = 'umap=0.5.4')"},{"path":"https://fspecque.github.io/test/articles/SeuratIntegrate.html","id":"preprocessing-with-seurat","dir":"Articles","previous_headings":"","what":"Preprocessing with Seurat","title":"Introduction to SeuratIntegrate","text":"ensure SeuratIntegrate works well, indispensable split Seurat object. process distributes cells single-batch layers batch normalized independently. account potential technical variability samples designating “ID_sample” batch variable.","code":"batch.var <- \"ID_sample\"  # save for later  liver_small <- split(liver_small, f = liver_small$ID_sample) liver_small <- SCTransform(liver_small)  liver_small <- RunPCA(liver_small) liver_small <- FindNeighbors(liver_small, dims = 1:20, k.param = 15L) liver_small <- RunUMAP(liver_small, dims = 1:20, n.neighbors = 15) DimPlot(liver_small, group.by = c(\"First_author\", \"ID_sample\")) DimPlot(liver_small, group.by = cell.var)"},{"path":"https://fspecque.github.io/test/articles/SeuratIntegrate.html","id":"integration-with-seuratintegrate","dir":"Articles","previous_headings":"","what":"Integration with SeuratIntegrate","title":"Introduction to SeuratIntegrate","text":"take look Seurat object, can note enriched many objects: Important outputs : New assay combat.reconstructed New reduction harmony New graphs bbknn_ridge.residuals_[…]","code":"liver_small <-   DoIntegrate(object = liver_small,                            # integrations               CombatIntegration(),               bbknnIntegration(orig = \"pca\", ndims.use = 20),               SeuratIntegrate::HarmonyIntegration(orig = \"pca\", dims = 1:20),                            # additional parameters               use.hvg = TRUE,               use.future = c(FALSE, TRUE, FALSE) ) ## Integration 1 in 3: integrating using 'CombatIntegration' ## Integration 2 in 3: integrating using 'bbknnIntegration' ## Modularity Optimizer version 1.3.0 by Ludo Waltman and Nees Jan van Eck ##  ## Number of nodes: 200 ## Number of edges: 1784 ##  ## Running Louvain algorithm... ## Maximum modularity in 10 random starts: 0.6251 ## Number of communities: 5 ## Elapsed time: 0 seconds ## Integration 3 in 3: integrating using 'SeuratIntegrate::HarmonyIntegration' print(liver_small) cat(\"\\n#####\\n\\n\") print(Graphs(liver_small)) ## An object of class Seurat  ## 22602 features across 200 samples within 4 assays  ## Active assay: SCT (6534 features, 3000 variable features) ##  3 layers present: counts, data, scale.data ##  3 other assays present: RNA, combat.reconstructed, bbknn.ridge ##  4 dimensional reductions calculated: pca, umap, pca.bbknn, harmony ##  ## ##### ##  ## [1] \"SCT_nn\"                               ## [2] \"SCT_snn\"                              ## [3] \"bbknn_scale.data_connectivities\"      ## [4] \"bbknn_scale.data_distances\"           ## [5] \"bbknn_ridge.residuals_connectivities\" ## [6] \"bbknn_ridge.residuals_distances\""},{"path":"https://fspecque.github.io/test/articles/SeuratIntegrate.html","id":"post-processing","dir":"Articles","previous_headings":"","what":"Post-processing","title":"Introduction to SeuratIntegrate","text":"type output important consider, scoring metrics compatible output types. simplest strategy process output separately order obtain least PCA , even knn graph (indispensable compute clusters). Note several scores computed knn graphs, hence knn graph outputs (e.g. BBKNN) can evaluated reduced set metrics. summary output type (bracketed steps always necessary): corrected counts: [ScaleData()] -> RunPCA() -> [FindNeighbors() -> FindOptimalClusters()] Dimension reduction: [RunPCA()] -> [FindNeighbors() -> FindOptimalClusters()] knn graph: [FindOptimalClusters()] , use SymmetrizeKnn() FindNeighbors() FindOptimalClusters() return.neighbor = TRUE. useful keep distances cells KNN graph. Although compulsory, used stay line BBKNN’s output. prevent community detection algorithm output high fraction singletons, “symmetrize” matrix makes graph “undirected”.","code":"# corrected counts outputs DefaultAssay(liver_small) <- \"combat.reconstructed\" VariableFeatures(liver_small) <- VariableFeatures(liver_small[[\"SCT\"]]) liver_small <- ScaleData(liver_small)  liver_small <- RunPCA(liver_small, npcs = 50L, reduction.name = \"pca.combat\") liver_small <- FindNeighbors(liver_small, reduction = \"pca.combat\", dims = 1:20,                      return.neighbor = TRUE, graph.name = \"knn.combat\") liver_small <- SymmetrizeKnn(liver_small, graph.name = \"knn.combat\") liver_small <- FindOptimalClusters(liver_small, graph.name = \"knn.combat_symmetric\",                            cluster.name = \"combat_{cell.var}_{metric}\",                            cell.var = cell.var,                            optimisation.metric = c(\"nmi\", \"ari\")) # default, compute both  DefaultAssay(liver_small) <- \"SCT\" # dimension reduction outputs liver_small <- FindNeighbors(liver_small, reduction = \"pca\", dims = 1:20, k.param = 20L,                      return.neighbor = TRUE, graph.name = \"knn.unintegrated\") liver_small <- SymmetrizeKnn(liver_small, graph.name = \"knn.unintegrated\") liver_small <- FindOptimalClusters(liver_small, graph.name = \"knn.unintegrated_symmetric\",                            cluster.name = \"unintegrated_{cell.var}_{metric}\",                            cell.var = cell.var)   liver_small <- FindNeighbors(liver_small, reduction = \"harmony\", dims = 1:20,                      return.neighbor = TRUE, graph.name = \"knn.harmony\") liver_small <- SymmetrizeKnn(liver_small, graph.name = \"knn.harmony\") liver_small <- FindOptimalClusters(liver_small, graph.name = \"knn.harmony_symmetric\", cell.var = cell.var,                            cluster.name = \"harmony_{cell.var}_{metric}\") # graph outputs liver_small <- SymmetrizeKnn(liver_small, graph.name = \"bbknn_ridge.residuals_distances\") liver_small <- FindOptimalClusters(liver_small, graph.name = \"bbknn_ridge.residuals_distances_symmetric\",                            cell.var = cell.var, cluster.name = \"bbknn_{cell.var}_{metric}\")"},{"path":"https://fspecque.github.io/test/articles/SeuratIntegrate.html","id":"scoring-1","dir":"Articles","previous_headings":"","what":"Scoring","title":"Introduction to SeuratIntegrate","text":"Now post-processed integration’s output, can compute multiple scores estimate accuracy integrations.","code":""},{"path":"https://fspecque.github.io/test/articles/SeuratIntegrate.html","id":"scores-not-requiring-a-cell-type-variable","dir":"Articles","previous_headings":"Scoring","what":"Scores not requiring a cell type variable","title":"Introduction to SeuratIntegrate","text":"scores run dimension reduction (PCA) compatible graph outputs. cell-type free score thus require cell-type label variable.","code":"liver_small <- AddScoreRegressPC(liver_small, integration = \"unintegrated\",                                  batch.var = batch.var, reduction = \"pca\") liver_small <- AddScoreRegressPC(liver_small, integration = \"combat\",                                  batch.var = batch.var, reduction = \"pca.combat\") liver_small <- AddScoreRegressPC(liver_small, integration = \"harmony\",                                  batch.var = batch.var, reduction = \"harmony\")  liver_small <- AddScoreDensityPC(liver_small, integration = \"unintegrated\",                                  batch.var = batch.var, reduction = \"pca\") liver_small <- AddScoreDensityPC(liver_small, integration = \"combat\",                                  batch.var = batch.var, reduction = \"pca.combat\") liver_small <- AddScoreRegressPC(liver_small, integration = \"harmony\",                                  batch.var = batch.var, reduction = \"harmony\")  liver_small <- CellCycleScoringPerBatch(liver_small, batch.var = batch.var,                                         s.features = cc.genes$s.genes,                                         g2m.features = cc.genes$g2m.genes) liver_small <- AddScoreRegressPC.CellCycle(liver_small, integration = \"unintegrated\",                                            batch.var = batch.var, what = \"pca\",                                            compute.cc = FALSE, dims.use = 1:20) liver_small <- AddScoreRegressPC.CellCycle(liver_small, integration = \"combat\",                                            batch.var = batch.var, what = \"pca.combat\",                                            compute.cc = FALSE, dims.use = 1:20) liver_small <- AddScoreRegressPC.CellCycle(liver_small, integration = \"harmony\",                                            batch.var = batch.var, what = \"harmony\",                                            compute.cc = FALSE, dims.use = 1:20)"},{"path":"https://fspecque.github.io/test/articles/SeuratIntegrate.html","id":"scores-based-on-silhouette-width","dir":"Articles","previous_headings":"Scoring","what":"Scores based on silhouette width","title":"Introduction to SeuratIntegrate","text":"scores return average silhouette width (ASW), either per cell type label per batch. run dimension reduction (PCA) compatible graph outputs. based cell-type label variable. However, ScoreASWBatch() can run cell-type label independent manner per.cell.var = FALSE.","code":"liver_small <- AddScoreASW(liver_small, integration = \"unintegrated\",                            cell.var = cell.var, what = \"pca\") liver_small <- AddScoreASW(liver_small, integration = \"combat\",                            cell.var = cell.var, what = \"pca.combat\") liver_small <- AddScoreASW(liver_small, integration = \"harmony\",                            cell.var = cell.var, what = \"harmony\")  liver_small <- AddScoreASWBatch(liver_small, integration = \"unintegrated\",                                 batch.var = batch.var, cell.var = cell.var,                                 what = \"pca\") liver_small <- AddScoreASWBatch(liver_small, integration = \"combat\",                                 batch.var = batch.var, cell.var = cell.var,                                 what = \"pca.combat\") liver_small <- AddScoreASWBatch(liver_small, integration = \"harmony\",                                 batch.var = batch.var, cell.var = cell.var,                                 what = \"harmony\")"},{"path":"https://fspecque.github.io/test/articles/SeuratIntegrate.html","id":"scores-working-on-a-graph","dir":"Articles","previous_headings":"Scoring","what":"Scores working on a graph","title":"Introduction to SeuratIntegrate","text":"scores graph outputs. require cell-type label variable.","code":"liver_small <- AddScoreConnectivity(liver_small, integration = \"unintegrated\",                                     graph.name = \"knn.unintegrated_symmetric\",                                     cell.var = cell.var) liver_small <- AddScoreConnectivity(liver_small, integration = \"combat\",                                     graph.name = \"knn.combat_symmetric\",                                     cell.var = cell.var) liver_small <- AddScoreConnectivity(liver_small, integration = \"harmony\",                                     graph.name = \"knn.harmony_symmetric\",                                     cell.var = cell.var) liver_small <- AddScoreConnectivity(liver_small, integration = \"bbknn\",                                     graph.name = \"bbknn_ridge.residuals_distances_symmetric\",                                     cell.var = cell.var)  liver_small <- AddScoreLISI(liver_small, integration = \"unintegrated\",                             batch.var = batch.var, cell.var = cell.var,                             reduction = \"pca\") liver_small <- AddScoreLISI(liver_small, integration = \"combat\",                             batch.var = batch.var, cell.var = cell.var,                             reduction = \"pca.combat\") liver_small <- AddScoreLISI(liver_small, integration = \"harmony\",                             batch.var = batch.var, cell.var = cell.var,                             reduction = \"harmony\") liver_small <- AddScoreLISI(liver_small, integration = \"bbknn\",                             batch.var = batch.var, cell.var = cell.var,                             reduction = NULL,                             graph.name = \"bbknn_ridge.residuals_distances_symmetric\")"},{"path":"https://fspecque.github.io/test/articles/SeuratIntegrate.html","id":"scores-comparing-two-categorical-variables","dir":"Articles","previous_headings":"Scoring","what":"Scores comparing two categorical variables","title":"Introduction to SeuratIntegrate","text":"scores compare two categorical variables. Thus, don’t need anything else cell-type cluster assignment variables (computed Post-processing FindOptimalClusters()).","code":"liver_small <- AddScoreARI(liver_small, integration = \"unintegrated\",                            cell.var = cell.var,                            clust.var = paste(\"unintegrated\", cell.var, \"ari\", sep = \"_\")) liver_small <- AddScoreARI(liver_small, integration = \"combat\",                            cell.var = cell.var,                            clust.var = paste(\"combat\", cell.var, \"ari\", sep = \"_\")) liver_small <- AddScoreARI(liver_small, integration = \"harmony\",                            cell.var = cell.var,                            clust.var = paste(\"harmony\", cell.var, \"ari\", sep = \"_\")) liver_small <- AddScoreARI(liver_small, integration = \"bbknn\",                            cell.var = cell.var,                            clust.var = paste(\"bbknn\", cell.var, \"ari\", sep = \"_\"))  liver_small <- AddScoreNMI(liver_small, integration = \"unintegrated\",                            cell.var = cell.var,                            clust.var = paste(\"unintegrated\", cell.var, \"nmi\", sep = \"_\")) liver_small <- AddScoreNMI(liver_small, integration = \"combat\",                            cell.var = cell.var,                            clust.var = paste(\"combat\", cell.var, \"nmi\", sep = \"_\")) liver_small <- AddScoreNMI(liver_small, integration = \"harmony\",                            cell.var = cell.var,                            clust.var = paste(\"harmony\", cell.var, \"nmi\", sep = \"_\")) liver_small <- AddScoreNMI(liver_small, integration = \"bbknn\",                            cell.var = cell.var,                            clust.var = paste(\"bbknn\", cell.var, \"nmi\", sep = \"_\"))"},{"path":"https://fspecque.github.io/test/articles/SeuratIntegrate.html","id":"scaling-and-comparison","dir":"Articles","previous_headings":"Scoring","what":"Scaling and comparison","title":"Introduction to SeuratIntegrate","text":"Now obtained several scores per integration, can compare performances. First, let’s scale scores zero one standardize direction (closer one, always better). step makes things easier compare improves interpretability. Now, let’s plot integrations.  can observe 3 overall scores computed, namely batch correction, bio-conservation overall (average last two). balance score’s contribution overall scores, min-max rescaling applied score scaling, stretching original score’s bounds zero one. can disabled preview original scores:  can also hide scores integrations. instance, “PCA.density” “PCA.regression” hardly informative. Let’s exclude see affects overall scores:  Interestingly, obtained ranking integrations first figure.","code":"liver_small <- ScaleScores(liver_small) PlotScores(liver_small) PlotScores(liver_small, rescale = FALSE) PlotScores(liver_small, rescale = FALSE, exclude.score = c(\"PCA.density\", \"PCA.regression\"))"},{"path":"https://fspecque.github.io/test/articles/SeuratIntegrate.html","id":"projecting-integrations-on-umaps","dir":"Articles","previous_headings":"","what":"Projecting integrations on UMAPs","title":"Introduction to SeuratIntegrate","text":"also possible project cells UMAP computed integration’s output, complementary (visual) inspection integration performances. UMAP unintegrated data UMAP ComBat integration UMAP BBKNN integration","code":"liver_small <- RunUMAP(liver_small, dims = 1:20, reduction = \"pca.combat\",                        reduction.name = \"umap.combat\") liver_small <- RunUMAP(liver_small, dims = 1:20, reduction = \"harmony\",                        reduction.name = \"umap.harmony\")  library(future) plan(multisession) liver_small %<-% {   reticulate::use_condaenv('umap_0.5.4')   RunUMAP(liver_small, graph = \"bbknn_ridge.residuals_connectivities\",           umap.method = \"umap-learn\", n.epochs = 200L,           reduction.name = \"umap.bbknn\") } liver_small plan(sequential) DimPlot(liver_small, group.by = c(batch.var, cell.var), reduction = \"umap\") DimPlot(liver_small, group.by = c(batch.var, cell.var), reduction = \"umap.combat\") DimPlot(liver_small, group.by = c(batch.var, cell.var), reduction = \"umap.bbknn\") ## R version 4.4.2 (2024-10-31)   ## Platform: x86_64-pc-linux-gnu   ## Running under: Ubuntu 24.04.1 LTS   ##    ## Matrix products: default   ## BLAS:   /usr/lib/x86_64-linux-gnu/openblas-pthread/libblas.so.3    ## LAPACK: /usr/lib/x86_64-linux-gnu/openblas-pthread/libopenblasp-r0.3.26.so;  LAPACK version 3.12.0   ##    ## locale:   ##  [1] LC_CTYPE=C.UTF-8       LC_NUMERIC=C           LC_TIME=C.UTF-8          ##  [4] LC_COLLATE=C.UTF-8     LC_MONETARY=C.UTF-8    LC_MESSAGES=C.UTF-8      ##  [7] LC_PAPER=C.UTF-8       LC_NAME=C              LC_ADDRESS=C             ## [10] LC_TELEPHONE=C         LC_MEASUREMENT=C.UTF-8 LC_IDENTIFICATION=C      ##    ## time zone: UTC   ## tzcode source: system (glibc)   ##    ## attached base packages:   ## [1] stats     graphics  grDevices utils     datasets  methods   base        ##    ## other attached packages:   ## [1] future_1.34.0         dplyr_1.1.4           SeuratIntegrate_0.4.0   ## [4] Seurat_5.2.1          SeuratObject_5.0.2    sp_2.1-4                ##    ## loaded via a namespace (and not attached):   ##   [1] RcppAnnoy_0.0.22            splines_4.4.2                 ##   [3] later_1.4.1                 batchelor_1.22.0              ##   [5] tibble_3.2.1                polyclip_1.10-7               ##   [7] XML_3.99-0.18               fastDummies_1.7.5             ##   [9] lifecycle_1.0.4             edgeR_4.4.1                   ##  [11] globals_0.16.3              lattice_0.22-6                ##  [13] MASS_7.3-61                 backports_1.5.0               ##  [15] magrittr_2.0.3              limma_3.62.2                  ##  [17] plotly_4.10.4               sass_0.4.9                    ##  [19] rmarkdown_2.29              jquerylib_0.1.4               ##  [21] yaml_2.3.10                 httpuv_1.6.15                 ##  [23] glmGamPoi_1.18.0            sctransform_0.4.1             ##  [25] spam_2.11-1                 spatstat.sparse_3.1-0         ##  [27] reticulate_1.40.0           DBI_1.2.3                     ##  [29] cowplot_1.1.3               pbapply_1.7-2                 ##  [31] RColorBrewer_1.1-3          ResidualMatrix_1.16.0         ##  [33] abind_1.4-8                 zlibbioc_1.52.0               ##  [35] Rtsne_0.17                  GenomicRanges_1.58.0          ##  [37] purrr_1.0.2                 BiocGenerics_0.52.0           ##  [39] tweenr_2.0.3                rappdirs_0.3.3                ##  [41] sva_3.54.0                  GenomeInfoDbData_1.2.13       ##  [43] IRanges_2.40.1              S4Vectors_0.44.0              ##  [45] ggrepel_0.9.6               irlba_2.3.5.1                 ##  [47] listenv_0.9.1               spatstat.utils_3.1-2          ##  [49] genefilter_1.88.0           goftest_1.2-3                 ##  [51] RSpectra_0.16-2             annotate_1.84.0               ##  [53] spatstat.random_3.3-2       fitdistrplus_1.2-2            ##  [55] parallelly_1.41.0           pkgdown_2.1.1                 ##  [57] DelayedMatrixStats_1.28.1   codetools_0.2-20              ##  [59] DelayedArray_0.32.0         ggforce_0.4.2                 ##  [61] scuttle_1.16.0              tidyselect_1.2.1              ##  [63] UCSC.utils_1.2.0            farver_2.1.2                  ##  [65] ScaledMatrix_1.14.0         matrixStats_1.5.0             ##  [67] stats4_4.4.2                spatstat.explore_3.3-4        ##  [69] jsonlite_1.8.9              BiocNeighbors_2.0.1           ##  [71] progressr_0.15.1            ggridges_0.5.6                ##  [73] survival_3.7-0              systemfonts_1.2.1             ##  [75] tools_4.4.2                 ragg_1.3.3                    ##  [77] ica_1.0-3                   Rcpp_1.0.14                   ##  [79] glue_1.8.0                  gridExtra_2.3                 ##  [81] SparseArray_1.6.1           mgcv_1.9-1                    ##  [83] xfun_0.50                   MatrixGenerics_1.18.1         ##  [85] GenomeInfoDb_1.42.1         withr_3.0.2                   ##  [87] fastmap_1.2.0               digest_0.6.37                 ##  [89] rsvd_1.0.5                  R6_2.5.1                      ##  [91] mime_0.12                   textshaping_1.0.0             ##  [93] colorspace_2.1-1            scattermore_1.2               ##  [95] tensor_1.5                  RSQLite_2.3.9                 ##  [97] spatstat.data_3.1-4         RhpcBLASctl_0.23-42           ##  [99] tidyr_1.3.1                 generics_0.1.3                ## [101] data.table_1.16.4           httr_1.4.7                    ## [103] htmlwidgets_1.6.4           S4Arrays_1.6.0                ## [105] uwot_0.2.2                  pkgconfig_2.0.3               ## [107] gtable_0.3.6                blob_1.2.4                    ## [109] lmtest_0.9-40               SingleCellExperiment_1.28.1   ## [111] XVector_0.46.0              htmltools_0.5.8.1             ## [113] dotCall64_1.2               scales_1.3.0                  ## [115] Biobase_2.66.0              png_0.1-8                     ## [117] lisi_1.0                    harmony_1.2.3                 ## [119] spatstat.univar_3.1-1       knitr_1.49                    ## [121] reshape2_1.4.4              nlme_3.1-166                  ## [123] cachem_1.1.0                zoo_1.8-12                    ## [125] stringr_1.5.1               KernSmooth_2.23-24            ## [127] parallel_4.4.2              miniUI_0.1.1.1                ## [129] AnnotationDbi_1.68.0        desc_1.4.3                    ## [131] pillar_1.10.1               grid_4.4.2                    ## [133] vctrs_0.6.5                 RANN_2.6.2                    ## [135] promises_1.3.2              BiocSingular_1.22.0           ## [137] distances_0.1.11            beachmat_2.22.0               ## [139] xtable_1.8-4                cluster_2.1.6                 ## [141] evaluate_1.0.3              locfit_1.5-9.10               ## [143] cli_3.6.3                   compiler_4.4.2                ## [145] rlang_1.1.5                 crayon_1.5.3                  ## [147] future.apply_1.11.3         labeling_0.4.3                ## [149] plyr_1.8.9                  forcats_1.0.0                 ## [151] fs_1.6.5                    stringi_1.8.4                 ## [153] viridisLite_0.4.2           deldir_2.0-4                  ## [155] BiocParallel_1.40.0         Biostrings_2.74.1             ## [157] munsell_0.5.1               lazyeval_0.2.2                ## [159] spatstat.geom_3.3-5         Matrix_1.7-1                  ## [161] RcppHNSW_0.6.0              patchwork_1.3.0               ## [163] bit64_4.6.0-1               sparseMatrixStats_1.18.0      ## [165] ggplot2_3.5.1               statmod_1.5.0                 ## [167] KEGGREST_1.46.0             shiny_1.10.0                  ## [169] SummarizedExperiment_1.36.0 ROCR_1.0-11                   ## [171] memoise_2.0.1               igraph_2.1.4                  ## [173] broom_1.0.7                 bslib_0.8.0                   ## [175] bit_4.5.0.1"},{"path":"https://fspecque.github.io/test/articles/introduction.html","id":"install-and-load-the-data","dir":"Articles","previous_headings":"","what":"Install and load the data","title":"Integration example with of the pbmcsca data","text":"use pbmcsca dataset available package SeuratData.","code":"# install `SeuratData` package (if not yet) if (! requireNamespace(\"SeuratData\", quietly = TRUE)) {   devtools::install_github('satijalab/seurat-data') }  # increase download timeout and install the dataset options(timeout = 300) SeuratData::InstallData('pbmcsca') # load the dataset (take 1,000 first cells to speed-up execution) seu <- SeuratData::LoadData('pbmcsca')[,1:1e3] ## Warning: Assay RNA changing from Assay to Assay ## Warning: Assay RNA changing from Assay to Assay5"},{"path":"https://fspecque.github.io/test/articles/introduction.html","id":"inspect-the-dataset","dir":"Articles","previous_headings":"","what":"Inspect the dataset","title":"Integration example with of the pbmcsca data","text":"look metadata: column Method provides information single-cell technology used acquire cell’s trancriptome. consider batch origin. column CellType contains cell-types annotation use later . Let’s now define batch variable cell-type variable(s):","code":"# rmarkdown::paged_table -> prints data frames in a less ugly way than default rmarkdown::paged_table(head(seu[[]], n = 10)) table(seu$Method) ##  ## 10x Chromium (v2) A            CEL-Seq2          Smart-seq2  ##                 494                 253                 253 rmarkdown::paged_table(as.data.frame(table(seu$CellType))) batch.var <- 'Method'   # available in the metadata of the object cell.var <- 'CellType'  # available in the metadata of the object"},{"path":"https://fspecque.github.io/test/articles/introduction.html","id":"seurat-data-processing---standard-workflow","dir":"Articles","previous_headings":"","what":"Seurat data processing - Standard workflow","title":"Integration example with of the pbmcsca data","text":"current Seurat object split, meaning layer contains cells batches. select column Method separate cells batch-specific layers. step indispensable run integration methods enables normalise batch (.e. layer) independently. , proceed standard Seurat workflow obtain PCA reduction.  now process object can visualise dispersion cells UMAP dimension reduction.  Let’s colour cells according batch cell-type label.  Albeit moderately, dispersion cells UMAP seems influenced batch effect. According “CellType” variable, B cells 10x CEL-Seq2 gathered together monocyte cells fully overlap. Now, want correct technical differences.","code":"cat('Layers before split:', paste(Layers(seu), collapse = \", \"), '\\n') ## Layers before split: counts, data seu[['RNA']] <- split(seu[['RNA']], f = seu$Method)  cat('Layers after split:', paste(Layers(seu), collapse = \", \"), '\\n') ## Layers after split: counts.Smart-seq2, counts.CEL-Seq2, counts.10x_Chromium_v2_A, data.Smart-seq2, data.CEL-Seq2, data.10x_Chromium_v2_A seu <- SCTransform(seu) seu <- RunPCA(seu, verbose = F) seu <- FindNeighbors(seu, reduction = \"pca\", dims = 1:30, k.param = 20L) seu <- FindClusters(seu, graph.name = 'SCT_snn', resolution = .5) seu <- RunUMAP(seu, dims = 1:30, reduction = 'pca') ## Modularity Optimizer version 1.3.0 by Ludo Waltman and Nees Jan van Eck ##  ## Number of nodes: 1000 ## Number of edges: 43767 ##  ## Running Louvain algorithm... ## Maximum modularity in 10 random starts: 0.8715 ## Number of communities: 8 ## Elapsed time: 0 seconds DimPlot(seu, label = T) + NoLegend() + ggplot2::coord_fixed(ratio = .7) DimPlot(seu, group.by = batch.var) +   DimPlot(seu, group.by = cell.var) & ggplot2::coord_fixed(ratio = .7)"},{"path":"https://fspecque.github.io/test/articles/introduction.html","id":"integrate-batches---seuratintegrate-workflow","dir":"Articles","previous_headings":"","what":"Integrate batches - SeuratIntegrate workflow","title":"Integration example with of the pbmcsca data","text":"integration commands extent similar Seurat V5 vignette. purpose package extend set available integration methods. See bottom ?IntegrateLayers comprehensive list relevant methods. Many methods supported SeuratIntegrate implemented Python, wrappers provided rely reticulate package conda environments. familiar CondaEnvManager, look vignette(\"setup_and_tips\"). important considerations performing integration: use interface DoIntegrate() SeuratIntegrate integrate cell batches (see next section) check method-specific arguments (e.g. ?bbknnIntegration) CondaEnvManager via UpdateEnvCache() (check vignette(\"setup_and_tips\")) custom conda environment passing path - name - conda_env parameter. overrides default behaviour loading specified environment instead fetching CondaEnvManager’s cache. methods expect raw count matrix, others expect scaled counts variable features, etc. help choice, look table data (recon loss “mse”) counts (otherwise) Layers: counts: raw counts data: normalised counts scale.data: scaled normalised counts variable features /!\\ IMPORTANT /!\\  use features calling integration method IntegrateLayers(): IntegrateLayers(object, features = Features(object), scale.layer = NULL). work SCTAssay.","code":""},{"path":"https://fspecque.github.io/test/articles/introduction.html","id":"dointegrate-philosophy-do_integrate","dir":"Articles","previous_headings":"Integrate batches - SeuratIntegrate workflow","what":"DoIntegrate philosophy (#do_integrate)","title":"Integration example with of the pbmcsca data","text":"function DoIntegrate() handy way run multiple integrations single command. Note : ... place specify integration commands run. integration commands expected function calls, .e. form FooIntegration(), BarIntegration(), etc. Calls accept method-specific argument (e.g. FooIntegration(layers = \"data\")) use.hvg = TRUE results using variable features use.future = TRUE useful run Python-based methods (normal R session load one conda instance, future enables launch background sessions, preventing main load conda environment.). highly recommended set FALSE R-based methods. integration methods can used without modifying default parameters. vignette, change arguments meet needs. Notably, change number cores allocated method (possible). vignette, going use 3 Python-based methods, namely BBKNN, Scanorama scANVI scvi-tools suite. Let’s make sure available straight away: Let’s proceed batch-effect corrections:","code":"ncores <- parallel::detectCores() - 2 # BBKNN if (! isValid(getCache()$bbknn)) {   UpdateEnvCache(\"bbknn\") } # Scanorama if (! isValid(getCache()$scanorama)) {   UpdateEnvCache(\"scanorama\") } # scvi-tools if (! isValid(getCache()$scanvi)) {   UpdateEnvCache(\"scanvi\") }"},{"path":"https://fspecque.github.io/test/articles/introduction.html","id":"integration-part-1-using-r-based-methods","dir":"Articles","previous_headings":"Integrate batches - SeuratIntegrate workflow","what":"Integration part 1) Using R-based methods","title":"Integration example with of the pbmcsca data","text":"Note: use SeuratIntegrate:: HarmonyIntegration avoid confusion Seurat::HarmonyIntegration().","code":"seu <- DoIntegrate(   object = seu,   SeuratIntegrate::HarmonyIntegration(orig = \"pca\", dims = 1:30,                                       ncores = ncores),   CCAIntegration(orig = \"pca\", dims = 1:30 , new.reduction = \"cca.integrated\",                  normalization.method = \"SCT\"),   RPCAIntegration(orig = \"pca\", dims = 1:30, new.reduction = \"rpca.integrated\",                   normalization.method = \"SCT\"),   use.future = FALSE  # R-based ) ## Integration 1 in 3: integrating using 'SeuratIntegrate::HarmonyIntegration' ## Integration 2 in 3: integrating using 'CCAIntegration' ## Integration 3 in 3: integrating using 'RPCAIntegration'"},{"path":"https://fspecque.github.io/test/articles/introduction.html","id":"integration-part-2-using-python-based-methods","dir":"Articles","previous_headings":"Integrate batches - SeuratIntegrate workflow","what":"Integration part 2) Using python-based methods","title":"Integration example with of the pbmcsca data","text":"Note: set max_epochs = 20L scANVIIntegration save time ! default number epochs (400) results superior integration. take look Seurat object, can note enriched many objects: Great! successfully performed several integrations! However, stopping unsatisfactory still need process integration’s output(s) obtain least one UMAP projection . , also aim generating assessable representations score.","code":"seu <- DoIntegrate(   object = seu,   bbknnIntegration(orig = \"pca\", layers = \"data\", ndims = 30),   ScanoramaIntegration(orig = \"pca\", ncores = ncores),   scANVIIntegration(groups = seu[[]], groups.name = \"Method\",                     labels.name = \"CellType\", layers = \"counts\",                     torch.intraop.threads = ncores,                     torch.interop.threads = ncores,                     max_epochs = 20L),   use.future = TRUE,  # Python-based   use.hvg = c(TRUE, TRUE, FALSE) ) ## Integration 1 in 3: integrating using 'bbknnIntegration' ## Modularity Optimizer version 1.3.0 by Ludo Waltman and Nees Jan van Eck ##  ## Number of nodes: 1000 ## Number of edges: 6866 ##  ## Running Louvain algorithm... ## Maximum modularity in 10 random starts: 0.6812 ## Number of communities: 10 ## Elapsed time: 0 seconds ## Integration 2 in 3: integrating using 'ScanoramaIntegration' ## Found 3000 genes among all datasets ## Processing datasets (0, 1) ## Processing datasets (0, 2) ## Processing datasets (1, 2) ## Integration 3 in 3: integrating using 'scANVIIntegration' ## INFO     Training for 20 epochs.                                                 ## Training:   0%|          | 0/20 [00:00<?, ?it/s]Epoch 1/20:   0%|          | 0/20 [00:00<?, ?it/s]Epoch 1/20:   5%|▌         | 1/20 [00:01<00:35,  1.89s/it]Epoch 1/20:   5%|▌         | 1/20 [00:01<00:35,  1.89s/it, v_num=1, train_loss_step=1.45e+4, train_loss_epoch=1.69e+4]Epoch 2/20:   5%|▌         | 1/20 [00:01<00:35,  1.89s/it, v_num=1, train_loss_step=1.45e+4, train_loss_epoch=1.69e+4]Epoch 2/20:  10%|█         | 2/20 [00:03<00:32,  1.82s/it, v_num=1, train_loss_step=1.45e+4, train_loss_epoch=1.69e+4]Epoch 2/20:  10%|█         | 2/20 [00:03<00:32,  1.82s/it, v_num=1, train_loss_step=1.38e+4, train_loss_epoch=1.37e+4]Epoch 3/20:  10%|█         | 2/20 [00:03<00:32,  1.82s/it, v_num=1, train_loss_step=1.38e+4, train_loss_epoch=1.37e+4]Epoch 3/20:  15%|█▌        | 3/20 [00:05<00:30,  1.78s/it, v_num=1, train_loss_step=1.38e+4, train_loss_epoch=1.37e+4]Epoch 3/20:  15%|█▌        | 3/20 [00:05<00:30,  1.78s/it, v_num=1, train_loss_step=1.07e+4, train_loss_epoch=1.18e+4]Epoch 4/20:  15%|█▌        | 3/20 [00:05<00:30,  1.78s/it, v_num=1, train_loss_step=1.07e+4, train_loss_epoch=1.18e+4]Epoch 4/20:  20%|██        | 4/20 [00:07<00:28,  1.78s/it, v_num=1, train_loss_step=1.07e+4, train_loss_epoch=1.18e+4]Epoch 4/20:  20%|██        | 4/20 [00:07<00:28,  1.78s/it, v_num=1, train_loss_step=1.66e+4, train_loss_epoch=1.08e+4]Epoch 5/20:  20%|██        | 4/20 [00:07<00:28,  1.78s/it, v_num=1, train_loss_step=1.66e+4, train_loss_epoch=1.08e+4]Epoch 5/20:  25%|██▌       | 5/20 [00:08<00:26,  1.75s/it, v_num=1, train_loss_step=1.66e+4, train_loss_epoch=1.08e+4]Epoch 5/20:  25%|██▌       | 5/20 [00:08<00:26,  1.75s/it, v_num=1, train_loss_step=9.38e+3, train_loss_epoch=1.03e+4]Epoch 6/20:  25%|██▌       | 5/20 [00:08<00:26,  1.75s/it, v_num=1, train_loss_step=9.38e+3, train_loss_epoch=1.03e+4]Epoch 6/20:  30%|███       | 6/20 [00:10<00:24,  1.72s/it, v_num=1, train_loss_step=9.38e+3, train_loss_epoch=1.03e+4]Epoch 6/20:  30%|███       | 6/20 [00:10<00:24,  1.72s/it, v_num=1, train_loss_step=1.72e+4, train_loss_epoch=9.9e+3] Epoch 7/20:  30%|███       | 6/20 [00:10<00:24,  1.72s/it, v_num=1, train_loss_step=1.72e+4, train_loss_epoch=9.9e+3]Epoch 7/20:  35%|███▌      | 7/20 [00:12<00:22,  1.71s/it, v_num=1, train_loss_step=1.72e+4, train_loss_epoch=9.9e+3]Epoch 7/20:  35%|███▌      | 7/20 [00:12<00:22,  1.71s/it, v_num=1, train_loss_step=1.05e+4, train_loss_epoch=9.68e+3]Epoch 8/20:  35%|███▌      | 7/20 [00:12<00:22,  1.71s/it, v_num=1, train_loss_step=1.05e+4, train_loss_epoch=9.68e+3]Epoch 8/20:  40%|████      | 8/20 [00:13<00:20,  1.70s/it, v_num=1, train_loss_step=1.05e+4, train_loss_epoch=9.68e+3]Epoch 8/20:  40%|████      | 8/20 [00:13<00:20,  1.70s/it, v_num=1, train_loss_step=1.78e+4, train_loss_epoch=9.5e+3] Epoch 9/20:  40%|████      | 8/20 [00:13<00:20,  1.70s/it, v_num=1, train_loss_step=1.78e+4, train_loss_epoch=9.5e+3]Epoch 9/20:  45%|████▌     | 9/20 [00:15<00:18,  1.69s/it, v_num=1, train_loss_step=1.78e+4, train_loss_epoch=9.5e+3]Epoch 9/20:  45%|████▌     | 9/20 [00:15<00:18,  1.69s/it, v_num=1, train_loss_step=7.85e+3, train_loss_epoch=9.37e+3]Epoch 10/20:  45%|████▌     | 9/20 [00:15<00:18,  1.69s/it, v_num=1, train_loss_step=7.85e+3, train_loss_epoch=9.37e+3]Epoch 10/20:  50%|█████     | 10/20 [00:17<00:16,  1.70s/it, v_num=1, train_loss_step=7.85e+3, train_loss_epoch=9.37e+3]Epoch 10/20:  50%|█████     | 10/20 [00:17<00:16,  1.70s/it, v_num=1, train_loss_step=7.37e+3, train_loss_epoch=9.26e+3]Epoch 11/20:  50%|█████     | 10/20 [00:17<00:16,  1.70s/it, v_num=1, train_loss_step=7.37e+3, train_loss_epoch=9.26e+3]Epoch 11/20:  55%|█████▌    | 11/20 [00:18<00:15,  1.70s/it, v_num=1, train_loss_step=7.37e+3, train_loss_epoch=9.26e+3]Epoch 11/20:  55%|█████▌    | 11/20 [00:18<00:15,  1.70s/it, v_num=1, train_loss_step=9.05e+3, train_loss_epoch=9.18e+3]Epoch 12/20:  55%|█████▌    | 11/20 [00:18<00:15,  1.70s/it, v_num=1, train_loss_step=9.05e+3, train_loss_epoch=9.18e+3]Epoch 12/20:  60%|██████    | 12/20 [00:20<00:13,  1.70s/it, v_num=1, train_loss_step=9.05e+3, train_loss_epoch=9.18e+3]Epoch 12/20:  60%|██████    | 12/20 [00:20<00:13,  1.70s/it, v_num=1, train_loss_step=9.66e+3, train_loss_epoch=9.11e+3]Epoch 13/20:  60%|██████    | 12/20 [00:20<00:13,  1.70s/it, v_num=1, train_loss_step=9.66e+3, train_loss_epoch=9.11e+3]Epoch 13/20:  65%|██████▌   | 13/20 [00:22<00:11,  1.69s/it, v_num=1, train_loss_step=9.66e+3, train_loss_epoch=9.11e+3]Epoch 13/20:  65%|██████▌   | 13/20 [00:22<00:11,  1.69s/it, v_num=1, train_loss_step=3.98e+3, train_loss_epoch=9.06e+3]Epoch 14/20:  65%|██████▌   | 13/20 [00:22<00:11,  1.69s/it, v_num=1, train_loss_step=3.98e+3, train_loss_epoch=9.06e+3]Epoch 14/20:  70%|███████   | 14/20 [00:24<00:10,  1.68s/it, v_num=1, train_loss_step=3.98e+3, train_loss_epoch=9.06e+3]Epoch 14/20:  70%|███████   | 14/20 [00:24<00:10,  1.68s/it, v_num=1, train_loss_step=1.16e+4, train_loss_epoch=8.98e+3]Epoch 15/20:  70%|███████   | 14/20 [00:24<00:10,  1.68s/it, v_num=1, train_loss_step=1.16e+4, train_loss_epoch=8.98e+3]Epoch 15/20:  75%|███████▌  | 15/20 [00:25<00:08,  1.67s/it, v_num=1, train_loss_step=1.16e+4, train_loss_epoch=8.98e+3]Epoch 15/20:  75%|███████▌  | 15/20 [00:25<00:08,  1.67s/it, v_num=1, train_loss_step=1.49e+4, train_loss_epoch=8.9e+3] Epoch 16/20:  75%|███████▌  | 15/20 [00:25<00:08,  1.67s/it, v_num=1, train_loss_step=1.49e+4, train_loss_epoch=8.9e+3]Epoch 16/20:  80%|████████  | 16/20 [00:27<00:06,  1.66s/it, v_num=1, train_loss_step=1.49e+4, train_loss_epoch=8.9e+3]Epoch 16/20:  80%|████████  | 16/20 [00:27<00:06,  1.66s/it, v_num=1, train_loss_step=4.98e+3, train_loss_epoch=8.86e+3]Epoch 17/20:  80%|████████  | 16/20 [00:27<00:06,  1.66s/it, v_num=1, train_loss_step=4.98e+3, train_loss_epoch=8.86e+3]Epoch 17/20:  85%|████████▌ | 17/20 [00:28<00:04,  1.66s/it, v_num=1, train_loss_step=4.98e+3, train_loss_epoch=8.86e+3]Epoch 17/20:  85%|████████▌ | 17/20 [00:28<00:04,  1.66s/it, v_num=1, train_loss_step=6.78e+3, train_loss_epoch=8.81e+3]Epoch 18/20:  85%|████████▌ | 17/20 [00:28<00:04,  1.66s/it, v_num=1, train_loss_step=6.78e+3, train_loss_epoch=8.81e+3]Epoch 18/20:  90%|█████████ | 18/20 [00:30<00:03,  1.66s/it, v_num=1, train_loss_step=6.78e+3, train_loss_epoch=8.81e+3]Epoch 18/20:  90%|█████████ | 18/20 [00:30<00:03,  1.66s/it, v_num=1, train_loss_step=5.82e+3, train_loss_epoch=8.79e+3]Epoch 19/20:  90%|█████████ | 18/20 [00:30<00:03,  1.66s/it, v_num=1, train_loss_step=5.82e+3, train_loss_epoch=8.79e+3]Epoch 19/20:  95%|█████████▌| 19/20 [00:32<00:01,  1.68s/it, v_num=1, train_loss_step=5.82e+3, train_loss_epoch=8.79e+3]Epoch 19/20:  95%|█████████▌| 19/20 [00:32<00:01,  1.68s/it, v_num=1, train_loss_step=5.13e+3, train_loss_epoch=8.72e+3]Epoch 20/20:  95%|█████████▌| 19/20 [00:32<00:01,  1.68s/it, v_num=1, train_loss_step=5.13e+3, train_loss_epoch=8.72e+3]Epoch 20/20: 100%|██████████| 20/20 [00:34<00:00,  1.68s/it, v_num=1, train_loss_step=5.13e+3, train_loss_epoch=8.72e+3]Epoch 20/20: 100%|██████████| 20/20 [00:34<00:00,  1.68s/it, v_num=1, train_loss_step=1.44e+4, train_loss_epoch=8.68e+3]Epoch 20/20: 100%|██████████| 20/20 [00:34<00:00,  1.70s/it, v_num=1, train_loss_step=1.44e+4, train_loss_epoch=8.68e+3] print(seu) ## An object of class Seurat  ## 69594 features across 1000 samples within 4 assays  ## Active assay: SCT (16450 features, 3000 variable features) ##  3 layers present: counts, data, scale.data ##  3 other assays present: RNA, bbknn.ridge, scanorama.reconstructed ##  8 dimensional reductions calculated: pca, umap, harmony, cca.integrated, rpca.integrated, pca.bbknn, integrated.scanorama, integrated.scANVI cat(\"Graph objects:\", paste(Graphs(seu), collapse = \", \"), \"\\n\") cat(\"Neighbor objects:\", paste(Neighbors(seu), collapse = \", \"), \"\\n\") cat(\"Reduction dimensions:\", paste(Reductions(seu), collapse = \", \"), \"\\n\") cat(\"Assays:\", paste(Assays(seu), collapse = \", \"), \"\\n\") ## Graph objects: SCT_nn, SCT_snn, bbknn_scale.data_connectivities, bbknn_scale.data_distances, bbknn_ridge.residuals_connectivities, bbknn_ridge.residuals_distances  ## Neighbor objects:   ## Reduction dimensions: pca, umap, harmony, cca.integrated, rpca.integrated, pca.bbknn, integrated.scanorama, integrated.scANVI  ## Assays: RNA, SCT, bbknn.ridge, scanorama.reconstructed"},{"path":[]},{"path":"https://fspecque.github.io/test/articles/introduction.html","id":"process-outputs","dir":"Articles","previous_headings":"Score integrations","what":"Process outputs","title":"Integration example with of the pbmcsca data","text":"Several objects can produced integration algorithm, namely layer new assay (.e. corrected counts), dimension reduction (corrected embedding), knn network. even produce one output (instance Scanorama produces corrected counts dimension reduction). type output important consider, scoring metrics compatible output types. simplest strategy process output separately order obtain least PCA , even knn graph (essential compute clusters). Note scores computed knn graphs, hence knn graph outputs (e.g. BBKNN) can evaluated reduced set metrics. summary post-processing steps output type (bracketed steps always necessary): corrected counts: [ScaleData()] -> RunPCA() -> [FindNeighbors() -> FindOptimalClusters()] dimension reduction: [RunPCA()] -> [FindNeighbors() -> FindOptimalClusters()] knn graph: [FindOptimalClusters()] RunPCA() sometimes run even dimension reduction objects (within scoring functions) scores require variance associated dimension. Let’s process outputs. , go steps exhaustive demonstration. However, noted skipping final step FindOptimalClusters() makes neighbour graph computation step (FindNeighbors()) unnecessary. case however, one forgo two scoring metrics, namely ARI NMI. , use SymmetrizeKnn() FindNeighbors() FindOptimalClusters() set return.neighbor = TRUE FindNeighbors(). useful keep distances cells KNN graph rather FindNeighbors() default, converting KNN graph adjacency matrix 0/1s SNN network values bounded 0 1. compulsory, used stay line BBKNN’s output. prevent community detection algorithm output high fraction singletons, “symmetrize” matrix makes graph “undirected”. Note: Instead sticking default FindNeighbors(return.neighbors = FALSE) beginning, switched TRUE right away, process KNN graph SymmetrizeKnn() use subsequent steps (umap, clustering, etc.) FindOptimalClusters() adds metadata columns clustering results maximized metric (NMI ARI) Seurat object:","code":"# corrected counts outputs DefaultAssay(seu) <- \"scanorama.reconstructed\" seu <- ScaleData(seu) seu <- RunPCA(seu, npcs = 50L, reduction.name = \"pca.scanorama_counts\") seu <- FindNeighbors(seu, reduction = \"pca.scanorama_counts\", dims = 1:30, return.neighbor = TRUE,                      graph.name = \"knn.scanorama_counts\") seu <- SymmetrizeKnn(seu, graph.name = \"knn.scanorama_counts\") seu <- FindOptimalClusters(seu, graph.name = \"knn.scanorama_counts_symmetric\",                            cluster.name = \"scanorama_counts_{cell.var}_{metric}\",                            cell.var = cell.var,                            optimisation.metric = c(\"nmi\", \"ari\")) # default, compute both   # dimension reduction outputs DefaultAssay(seu) <- \"SCT\" seu <- FindNeighbors(seu, reduction = \"pca\", dims = 1:30, k.param = 20L,                      return.neighbor = TRUE, graph.name = \"knn.unintegrated\") seu <- SymmetrizeKnn(seu, graph.name = \"knn.unintegrated\") seu <- FindOptimalClusters(seu, graph.name = \"knn.unintegrated_symmetric\",                            cluster.name = \"unintegrated_{cell.var}_{metric}\",                            cell.var = cell.var)  seu <- FindNeighbors(seu, reduction = \"integrated.scanorama\", dims = 1:30,                      return.neighbor = TRUE, graph.name = \"knn.scanorama_reduction\") seu <- SymmetrizeKnn(seu, graph.name = \"knn.scanorama_reduction\") seu <- FindOptimalClusters(seu, graph.name = \"knn.scanorama_reduction_symmetric\",                            cluster.name = \"scanorama_reduction_{cell.var}_{metric}\",                            cell.var = cell.var)  seu <- FindNeighbors(seu, reduction = \"harmony\", dims = 1:30,                      return.neighbor = TRUE, graph.name = \"knn.harmony\") seu <- SymmetrizeKnn(seu, graph.name = \"knn.harmony\") seu <- FindOptimalClusters(seu, graph.name = \"knn.harmony_symmetric\", cell.var = cell.var,                            cluster.name = \"harmony_{cell.var}_{metric}\")  seu <- FindNeighbors(seu, reduction = \"cca.integrated\", dims = 1:30,                      return.neighbor = TRUE, graph.name = \"knn.cca\") seu <- SymmetrizeKnn(seu, graph.name = \"knn.cca\") seu <- FindOptimalClusters(seu, graph.name = \"knn.cca_symmetric\", cell.var = cell.var,                            cluster.name = \"cca_{cell.var}_{metric}\")  seu <- FindNeighbors(seu, reduction = \"rpca.integrated\", dims = 1:30,                      return.neighbor = TRUE, graph.name = \"knn.rpca\") seu <- SymmetrizeKnn(seu, graph.name = \"knn.rpca\") seu <- FindOptimalClusters(seu, graph.name = \"knn.rpca_symmetric\", cell.var = cell.var,                            cluster.name = \"rpca_{cell.var}_{metric}\")  seu <- FindNeighbors(seu, reduction = \"integrated.scANVI\",                      return.neighbor = TRUE, graph.name = \"knn.scanvi\") seu <- SymmetrizeKnn(seu, graph.name = \"knn.scanvi\") seu <- FindOptimalClusters(seu, graph.name = \"knn.scanvi_symmetric\", cell.var = cell.var,                            cluster.name = \"scanvi_{cell.var}_{metric}\")   # graph outputs seu <- SymmetrizeKnn(seu, graph.name = \"bbknn_ridge.residuals_distances\") seu <- FindOptimalClusters(seu, graph.name = \"bbknn_ridge.residuals_distances_symmetric\",                            cell.var = cell.var, cluster.name = \"bbknn_{cell.var}_{metric}\") rmarkdown::paged_table(seu[[]][1:10, grep(\"CellType_[arinm]{3}$\", colnames(seu[[]]))])"},{"path":"https://fspecque.github.io/test/articles/introduction.html","id":"add-scores-to-the-seurat-object","dir":"Articles","previous_headings":"Score integrations","what":"Add scores to the Seurat object","title":"Integration example with of the pbmcsca data","text":"Now computed objects ready scored, proceed assessing integration output. step, one can either use Score[score_name]() save scores separate variables use AddScore[score_name]() directly store scores within Seurat object. latter far convenient allows compare scores graphically. strategy going adopt . Last least, cell-type variable used scores, hence highly recommended estimate cell’s type (produce estimate) stored Seurat object column metadata. Note one doesn’t variable cell-labels (used ground truth multiple scores) produce without several scores. Alternatively, one can use automatic cell annotation algorithms (e.g. Azimuth package). One can also multiple cell label variables (e.g. Azimuth typically returns many cell label variables levels annotations contained reference). Scores requiring cell type annotations always accept multiple column names. risk confusion cell annotations using automatic cell annotation tools. Furthermore, case using Azimuth annotate cells, specific risk biasing results favouring RPCA integration Azimuth uses RPCA integrate query dataset onto reference. First , let’s organise outputs lists: Let’s finalise preparations: : Make sure kBET package installed run ScoreKBET() benefit faster implementation lisi algorithm, install lisi package benefit faster implementation euclidean distance computation, install distances package run ScoreRegressPC.CellCycle() (score cell cycle conservation), run CellCycleScoringPerBatch() beforehand (next chunk) Let’s now loop integration outputs: Now computed multiple scores, can look using IntegrationScores():","code":"reductions <- list(   unintegrated = \"pca\",   scanorama_counts = \"pca.scanorama_counts\",   scanorama_reduction = \"integrated.scanorama\",   harmony = \"harmony\",   cca = \"cca.integrated\",   rpca = \"rpca.integrated\",   scanvi = \"integrated.scANVI\",   bbknn = NULL )  graphs <- list(   unintegrated = \"knn.unintegrated_symmetric\",   scanorama_counts = \"knn.scanorama_counts_symmetric\",   scanorama_reduction = \"knn.scanorama_reduction_symmetric\",   harmony = \"knn.harmony_symmetric\",   cca = \"knn.cca_symmetric\",   rpca = \"knn.rpca_symmetric\",   scanvi = \"knn.scanvi_symmetric\",   bbknn = \"bbknn_ridge.residuals_distances_symmetric\" )  integrations <- names(reductions) seu <- CellCycleScoringPerBatch(seu, batch.var = batch.var,                                 s.features = cc.genes$s.genes,                                 g2m.features = cc.genes$g2m.genes) for (integ in integrations) {   reduc <- reductions[[integ]]   graph <- graphs[[integ]]   clust.var.ari <- paste(integ, cell.var, \"ari\", sep = \"_\") # produced by `FindOptimalClusters()`   clust.var.nmi <- paste(integ, cell.var, \"nmi\", sep = \"_\") # produced by `FindOptimalClusters()`   if (! is.null(reduc)) {   # all TRUE except bbknn     seu <- AddScoreASW(seu, integration = integ, cell.var = cell.var,                        what = reduc, dist.package = \"distances\")     seu <- AddScoreASWBatch(seu, integration = integ, batch.var = batch.var,                             cell.var = cell.var, what = reduc,                             dist.package = \"distances\")     seu <- AddScoreDensityPC(seu, integration = integ, batch.var = batch.var,                              reduction = reduc)     seu <- AddScoreRegressPC(seu, integration = integ, batch.var = batch.var,                              reduction = reduc)     seu <- AddScoreRegressPC.CellCycle(seu, integration = integ,                                        batch.var = batch.var, what = reduc,                                        compute.cc = FALSE) # because CellCycleScoringPerBatch was ran before   }   seu <- AddScoreARI(seu, integration = integ, cell.var = cell.var,                      clust.var = clust.var.ari)   seu <- AddScoreNMI(seu, integration = integ, cell.var = cell.var,                      clust.var = clust.var.nmi)   seu <- AddScoreConnectivity(seu, integration = integ, graph.name = graph,                               cell.var = cell.var)   seu <- AddScoreKBET(seu, integration = integ, batch.var = batch.var,                       cell.var = cell.var, what = reduc %||% sub(\"_symmetric$\", \"\", graph),                       graph.type = \"distances\", verbose = FALSE)   seu <- AddScoreLISI(seu, integration = integ, batch.var = batch.var,                       cell.var = cell.var, reduction = reduc,                       graph.name = if (is.null(reduc)) sub(\"_symmetric$\", \"\", graph) else NULL,                       graph.type = \"distances\", ncores = ncores)    } rmarkdown::paged_table(IntegrationScores(seu))"},{"path":"https://fspecque.github.io/test/articles/introduction.html","id":"compare-the-integrations","dir":"Articles","previous_headings":"Score integrations","what":"Compare the integrations","title":"Integration example with of the pbmcsca data","text":"Note scores raw. Let’s scale (make comparable): , can print : readily compare integrations, let’s plot scores:  One might notice difference scale scores, comparing plot table just . case PCA density score instance. Indeed, PlotScores() rescales scores using min-max normalisation default (rescale = TRUE). One might chose disable :  notice PCA based methods output low scores case. Since computed knn graphs, scores biased favour BBKNN. can exclude scores (recompute overall scores fly)  can chose different type plot (radar lollipop):  last plot, also exclude non-integrated dataset. Since rescale argument true default, scores rescaled without excluded integration’s scores.  want compare UMAP embeddings. , first compute dimension reductions: BBKNN’s output graph, need use umap Python package:   several observations made , require explanations: cells seem assigned wrong label CellType, highlighting importance cell annotations sufficient quality considered suitable ground truth (actually case ) scaled PCA regression scores set zero. unintegrated dataset lowest raw PCA regression score. likely consequence SCT normalisation, much efficient masking batch-specific differences classical LogNorm. Thus, inter-batch differences driving principal components. ScaleScores() produce scores can different scales (long rescale = FALSE) . Thus, min-max rescaling used default PlotScores(), balance score’s contribution overall scores. especially suited comparing large number integrations. However, drawbacks: can heavily distort scale scores maximum minimum far 1 0 respectively (e.g. cLISI scores 0.9). Hence, final decision whether use min-max rescaling left user’s discretion.","code":"seu <- ScaleScores(seu) rmarkdown::paged_table(IntegrationScores(seu, scaled = TRUE)) PlotScores(seu) print(sort(IntegrationScores(seu, scaled = TRUE)$PCA.density)) ## [1] 0.00000000 0.00000000 0.00000000 0.00000000 0.00000000 0.05713768 0.12268377 PlotScores(seu, rescale = FALSE) PlotScores(seu, rescale = FALSE, exclude.score = c(\"pca.density\", \"pca.regression\")) library(ggplot2) PlotScores(seu, plot.type = \"radar\") +   # reduce overlap between axis names and figures    theme(legend.position = \"top\", panel.spacing = unit(3, \"cm\"),         plot.margin = margin(r = 3, l = 3, unit = \"cm\"),         axis.text.x = element_text(size = 10)) ## Warning: Removed 5 rows containing missing values or values outside the scale range ## (`geom_point()`). PlotScores(seu, plot.type = \"lollipop\",              exclude.integration = \"unintegrated\") ## Warning: Removed 5 rows containing missing values or values outside the scale range ## (`geom_point()`). ## Warning: Removed 5 rows containing missing values or values outside the scale range ## (`geom_errorbarh()`). for (integ in integrations) {   reduc <- reductions[[integ]]   if (! is.null(reduc)) { # all except BBKNN     seu <- RunUMAP(seu, dims = 1:min(30, ncol(seu[[reduc]])), reduction = reduc,                    reduction.name = paste0(integ, \".umap\"))   } } if (! reticulate::condaenv_exists('umap_0.5.4')) {   reticulate::conda_create('umap_0.5.4', packages = 'umap=0.5.4') }  library(future) plan(multisession) seu %<-% {   reticulate::use_condaenv('umap_0.5.4')   RunUMAP(seu, graph = \"bbknn_ridge.residuals_connectivities\", umap.method = \"umap-learn\",           n.epochs = 200L, reduction.name = \"bbknn.umap\") } seu plan(sequential) library(ggplot2) plot_list <- sapply(integrations, function(integ) {   DimPlot(seu, reduction = paste0(integ, \".umap\"), group.by = batch.var) +     ggtitle(integ) +     theme(axis.title = element_blank()) }, simplify = FALSE)  patchwork::wrap_plots(plot_list, guides = \"collect\") library(ggplot2) plot_list <- sapply(integrations, function(integ) {   DimPlot(seu, reduction = paste0(integ, \".umap\"), group.by = cell.var) +     ggtitle(integ) +     theme(axis.title = element_blank()) }, simplify = FALSE)  patchwork::wrap_plots(plot_list, guides = \"collect\") ## R version 4.4.2 (2024-10-31)   ## Platform: x86_64-pc-linux-gnu   ## Running under: Ubuntu 24.04.1 LTS   ##    ## Matrix products: default   ## BLAS:   /usr/lib/x86_64-linux-gnu/openblas-pthread/libblas.so.3    ## LAPACK: /usr/lib/x86_64-linux-gnu/openblas-pthread/libopenblasp-r0.3.26.so;  LAPACK version 3.12.0   ##    ## locale:   ##  [1] LC_CTYPE=C.UTF-8       LC_NUMERIC=C           LC_TIME=C.UTF-8          ##  [4] LC_COLLATE=C.UTF-8     LC_MONETARY=C.UTF-8    LC_MESSAGES=C.UTF-8      ##  [7] LC_PAPER=C.UTF-8       LC_NAME=C              LC_ADDRESS=C             ## [10] LC_TELEPHONE=C         LC_MEASUREMENT=C.UTF-8 LC_IDENTIFICATION=C      ##    ## time zone: UTC   ## tzcode source: system (glibc)   ##    ## attached base packages:   ## [1] stats     graphics  grDevices utils     datasets  methods   base        ##    ## other attached packages:   ## [1] future_1.34.0         ggplot2_3.5.1         SeuratIntegrate_0.4.0   ## [4] Seurat_5.2.1          SeuratObject_5.0.2    sp_2.1-4                ##    ## loaded via a namespace (and not attached):   ##   [1] RcppAnnoy_0.0.22            splines_4.4.2                 ##   [3] later_1.4.1                 batchelor_1.22.0              ##   [5] tibble_3.2.1                polyclip_1.10-7               ##   [7] XML_3.99-0.18               fastDummies_1.7.5             ##   [9] lifecycle_1.0.4             edgeR_4.4.1                   ##  [11] globals_0.16.3              lattice_0.22-6                ##  [13] MASS_7.3-61                 backports_1.5.0               ##  [15] magrittr_2.0.3              limma_3.62.2                  ##  [17] plotly_4.10.4               sass_0.4.9                    ##  [19] rmarkdown_2.29              jquerylib_0.1.4               ##  [21] yaml_2.3.10                 httpuv_1.6.15                 ##  [23] glmGamPoi_1.18.0            sctransform_0.4.1             ##  [25] spam_2.11-1                 spatstat.sparse_3.1-0         ##  [27] reticulate_1.40.0           DBI_1.2.3                     ##  [29] cowplot_1.1.3               pbapply_1.7-2                 ##  [31] RColorBrewer_1.1-3          ResidualMatrix_1.16.0         ##  [33] abind_1.4-8                 zlibbioc_1.52.0               ##  [35] Rtsne_0.17                  GenomicRanges_1.58.0          ##  [37] purrr_1.0.2                 BiocGenerics_0.52.0           ##  [39] tweenr_2.0.3                rappdirs_0.3.3                ##  [41] sva_3.54.0                  GenomeInfoDbData_1.2.13       ##  [43] IRanges_2.40.1              S4Vectors_0.44.0              ##  [45] ggrepel_0.9.6               irlba_2.3.5.1                 ##  [47] listenv_0.9.1               spatstat.utils_3.1-2          ##  [49] genefilter_1.88.0           pbmcsca.SeuratData_3.0.0      ##  [51] goftest_1.2-3               RSpectra_0.16-2               ##  [53] annotate_1.84.0             spatstat.random_3.3-2         ##  [55] fitdistrplus_1.2-2          parallelly_1.41.0             ##  [57] pkgdown_2.1.1               DelayedMatrixStats_1.28.1     ##  [59] codetools_0.2-20            DelayedArray_0.32.0           ##  [61] ggforce_0.4.2               scuttle_1.16.0                ##  [63] tidyselect_1.2.1            UCSC.utils_1.2.0              ##  [65] farver_2.1.2                ScaledMatrix_1.14.0           ##  [67] matrixStats_1.5.0           stats4_4.4.2                  ##  [69] spatstat.explore_3.3-4      jsonlite_1.8.9                ##  [71] BiocNeighbors_2.0.1         progressr_0.15.1              ##  [73] ggridges_0.5.6              survival_3.7-0                ##  [75] systemfonts_1.2.1           tools_4.4.2                   ##  [77] ragg_1.3.3                  ica_1.0-3                     ##  [79] Rcpp_1.0.14                 glue_1.8.0                    ##  [81] gridExtra_2.3               SparseArray_1.6.1             ##  [83] mgcv_1.9-1                  xfun_0.50                     ##  [85] MatrixGenerics_1.18.1       GenomeInfoDb_1.42.1           ##  [87] dplyr_1.1.4                 withr_3.0.2                   ##  [89] fastmap_1.2.0               digest_0.6.37                 ##  [91] rsvd_1.0.5                  R6_2.5.1                      ##  [93] mime_0.12                   textshaping_1.0.0             ##  [95] colorspace_2.1-1            scattermore_1.2               ##  [97] tensor_1.5                  kBET_0.99.6                   ##  [99] RSQLite_2.3.9               spatstat.data_3.1-4           ## [101] RhpcBLASctl_0.23-42         tidyr_1.3.1                   ## [103] generics_0.1.3              data.table_1.16.4             ## [105] FNN_1.1.4.1                 httr_1.4.7                    ## [107] htmlwidgets_1.6.4           S4Arrays_1.6.0                ## [109] uwot_0.2.2                  pkgconfig_2.0.3               ## [111] gtable_0.3.6                blob_1.2.4                    ## [113] lmtest_0.9-40               SingleCellExperiment_1.28.1   ## [115] XVector_0.46.0              htmltools_0.5.8.1             ## [117] dotCall64_1.2               scales_1.3.0                  ## [119] Biobase_2.66.0              SeuratData_0.2.2.9001         ## [121] png_0.1-8                   lisi_1.0                      ## [123] harmony_1.2.3               spatstat.univar_3.1-1         ## [125] knitr_1.49                  reshape2_1.4.4                ## [127] nlme_3.1-166                cachem_1.1.0                  ## [129] zoo_1.8-12                  stringr_1.5.1                 ## [131] KernSmooth_2.23-24          parallel_4.4.2                ## [133] miniUI_0.1.1.1              AnnotationDbi_1.68.0          ## [135] desc_1.4.3                  pillar_1.10.1                 ## [137] grid_4.4.2                  vctrs_0.6.5                   ## [139] RANN_2.6.2                  promises_1.3.2                ## [141] BiocSingular_1.22.0         distances_0.1.11              ## [143] beachmat_2.22.0             xtable_1.8-4                  ## [145] cluster_2.1.6               evaluate_1.0.3                ## [147] locfit_1.5-9.10             cli_3.6.3                     ## [149] compiler_4.4.2              rlang_1.1.5                   ## [151] crayon_1.5.3                future.apply_1.11.3           ## [153] labeling_0.4.3              plyr_1.8.9                    ## [155] forcats_1.0.0               fs_1.6.5                      ## [157] stringi_1.8.4               viridisLite_0.4.2             ## [159] deldir_2.0-4                BiocParallel_1.40.0           ## [161] Biostrings_2.74.1           munsell_0.5.1                 ## [163] lazyeval_0.2.2              spatstat.geom_3.3-5           ## [165] Matrix_1.7-1                RcppHNSW_0.6.0                ## [167] patchwork_1.3.0             bit64_4.6.0-1                 ## [169] sparseMatrixStats_1.18.0    statmod_1.5.0                 ## [171] KEGGREST_1.46.0             shiny_1.10.0                  ## [173] SummarizedExperiment_1.36.0 ROCR_1.0-11                   ## [175] memoise_2.0.1               igraph_2.1.4                  ## [177] broom_1.0.7                 bslib_0.8.0                   ## [179] bit_4.5.0.1"},{"path":"https://fspecque.github.io/test/articles/setup_and_tips.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"Generic advice about setting up and using conda environments","text":"SeuratIntegrate’s main purpose extend range scRNA-seq integration tools available R compatible Seurat. Many solely available Python, developed wrappers leveraging reticulate package’s capabilities. reticulate enables directly call Python R, give conda environments set beforehand. purpose vignette illustrate ease installation use environments. Prior starting, make sure : conda installed machine conda binary PATH (know location)","code":""},{"path":"https://fspecque.github.io/test/articles/setup_and_tips.html","id":"set-up","dir":"Articles","previous_headings":"","what":"Set-up","title":"Generic advice about setting up and using conda environments","text":"need multiple conda environments. One bbknn, one Scanorama, one scVI/scANVI one trVAE. don’t plan using methods, whether decide set respective conda environments . One contrary, already conda environments appropriate libraries machine, can tell SeuratIntegrate use . Let’s see . look CondaEnvManager:  ’s handy way glance implemented methods status conda environments. ComBat, Harmony MNN R-based methods don’t need conda environment. rest however Python-based function reticulate, hence require conda environments. don’t conda environments , look next sub-section. Conversely, want add existing conda environment, directly go following one.","code":"library(SeuratIntegrate) getCache()"},{"path":"https://fspecque.github.io/test/articles/setup_and_tips.html","id":"create_env","dir":"Articles","previous_headings":"Set-up","what":"Option 1: Create new conda environments with SeuratIntegrate","title":"Generic advice about setting up and using conda environments","text":"Note commands tested Linux distributions Try following commands (aware execution might take time): Note : conda PATH set conda.bin = /path//conda scVI scANVI share environment. Hence, necessary run UpdateEnvCache('scvi') UpdateEnvCache('scanvi') look CondaEnvManager:","code":"UpdateEnvCache('bbknn') UpdateEnvCache('scvi') UpdateEnvCache('scanorama') UpdateEnvCache('trvae') getCache()"},{"path":"https://fspecque.github.io/test/articles/setup_and_tips.html","id":"use_env","dir":"Articles","previous_headings":"Set-up","what":"Option 2: Use existing conda environments","title":"Generic advice about setting up and using conda environments","text":"already one (several) existing conda environment(s) one () methods, can tell SeuratIntegrate use (). Similarly, run problems UpdateEnvCache() commands , alternative set conda environments provide SeuratIntegrate. Whatever case, let’s proceed. ’ll use UpdateEnvCache(). can specify name conda environment path . default, UpdateEnvCache() try decide whether provided value conda.env path name based simple tests. avoid misinterpretation, can use conda.env..path = TRUE FALSE input path name environment, respectively. beware make mistakes !!! See examples . adapt arguments situation: Note : conda PATH set conda.bin = /path//conda conda.bin must correspond conda managing conda.env scVI scANVI share environment. Hence, necessary run UpdateEnvCache('scvi') UpdateEnvCache('scanvi') Now can use Python-based methods !","code":"# environment for bbknn UpdateEnvCache('bbknn', conda.env = 'bbknn_env',                conda.env.is.path = FALSE)   # default 'auto' would work  # environment for bbknn in ./bbknn_env/ UpdateEnvCache('bbknn', conda.env = 'bbknn_env',                conda.env.is.path = TRUE)  # environment for bbknn, conda binary not in PATH UpdateEnvCache('bbknn', conda.env = 'bbknn_env', conda.bin = 'cutom/location/conda')  # path for scvi-tools UpdateEnvCache('scvi', conda.env = '~/miniconda3/envs/scvi-tools_env',                conda.env.is.path = TRUE)   # default 'auto' would work"},{"path":"https://fspecque.github.io/test/articles/setup_and_tips.html","id":"update-or-reset-conda-environments","dir":"Articles","previous_headings":"Set-up","what":"Update or reset conda environments","title":"Generic advice about setting up and using conda environments","text":"want update conda environment, use unset environment, use","code":"# change 'method' by the name of the method UpdateEnvCache(method = 'method', overwrite.env = TRUE, ...) # change 'method' by the name of the method resetCache(method = 'method')"},{"path":[]},{"path":"https://fspecque.github.io/test/articles/setup_and_tips.html","id":"install_problem","dir":"Articles","previous_headings":"Troubleshouting with conda","what":"Common issues with setting up environments","title":"Generic advice about setting up and using conda environments","text":"can happen conda environment installed specific machine os. case, hardly anything better browse internet hope someone else experienced similar problem solution public. Otherwise, try modify set packages install, less stringent package versions install, etc. can also create conda environment Python pip, try install packages pip rather conda. problem solved (can ), can save new environment CondaEnvManager ","code":"# change 'method' by the name of the method # change'difficult_conda_env' by the name of the working conda environment UpdateEnvCache(method = 'method', conda.env = 'difficult_conda_env')"},{"path":"https://fspecque.github.io/test/articles/setup_and_tips.html","id":"load_problem","dir":"Articles","previous_headings":"Troubleshouting with conda","what":"Possible issues with activating environments","title":"Generic advice about setting up and using conda environments","text":"can happen conda environment work (stops working) specific machine. potential causes conflicts Python libraries, conda components lead malfunctions (non exhaustive list): rmarkdown/knitr Check command works outside rmarkdown (e.g. R script), closed Rmardown file closed R session (restrated RStudio). something consider notably encounter error like: RStudio Check command works outside RStudio. instance, error integration scanpy imported, try: reticulate Check conda environment loads properly pure Python session. instance, error integration scanpy imported, try : First, try update reticulate. doesn’t work better, check someone encountered issue (browse web issues reticulate github repository. nothing works, either post issue reticulate github repos retry import installed different Python package versions. Python packages tricky. packages know incompatible. instance, jax jaxlib work better versions identical. experience, scvi-tools environment can set two discrepant versions jax jaxlib. check, try: local os list packages installed SeuratIntegrate","code":"ImportError: /opt/conda/envs/[env_name]/lib/python3.10/site-packages/PIL/../../../libtiff.so.6: undefined symbol: jpeg12_write_raw_data, version LIBJPEG_8.0 # from a terminal R > library(reticulate) > use_condaenv('[conda_env_name]') > scanpy <- import(\"scanpy\", convert = FALSE) # error here ? > conda activate [conda_env_name] python >>> import scanpy # error here ? >>> conda list -n [conda_env_name] jax"},{"path":"https://fspecque.github.io/test/articles/setup_and_tips.html","id":"subtleties-of-using-future","dir":"Articles","previous_headings":"","what":"Subtleties of using Future","title":"Generic advice about setting up and using conda environments","text":"following bullet points seem obscure, explanations given sections . brief, disable future R-based methods (DoIntegrate([...], use.future = FALSE)) never use CCA RPCA integration methods multisession (previous advice prevents , especially Windows users) multicore futures faster less memory-intensive multisession, unstable RStudio unavailable Windows force DoIntegrate() use multicore framework (risk), set options(parallelly.fork.enable = FALSE). Unavailable Windows","code":""},{"path":"https://fspecque.github.io/test/articles/setup_and_tips.html","id":"why-seuratintegrate-uses-future","dir":"Articles","previous_headings":"Subtleties of using Future","what":"Why SeuratIntegrate uses Future ?","title":"Generic advice about setting up and using conda environments","text":"R session can initialise one Python environment time via reticulate. known limitation reticualte overcome launching “background session” using Future. environment initialised instead main user’s R session. feature embedded DoIntegrate(). Futures therefore useless R-based methods disabled DoIntegrate([...], use.future = FALSE). Worse, discouraged CCAIntegration RPCAIntegration (explanations final part vignette)","code":""},{"path":"https://fspecque.github.io/test/articles/setup_and_tips.html","id":"inconveniences","dir":"Articles","previous_headings":"Subtleties of using Future","what":"Inconveniences","title":"Generic advice about setting up and using conda environments","text":"vast majority cases, impact “futures” insignificant. obvious needed seconds launch future session export globals, addition reordering stdout message output, resulting messy less informative print statements intended user.","code":""},{"path":"https://fspecque.github.io/test/articles/setup_and_tips.html","id":"tweaks","dir":"Articles","previous_headings":"Subtleties of using Future","what":"Tweaks","title":"Generic advice about setting up and using conda environments","text":"package implements sequential, multicore, multisession, cluster futures. SeuratIntegrate uses multicore multisession ones. DoIntegrate() automatically picks preferred one based output multicore supported, thus DoIntegrate() start multisession. explanations regarding settings giving priority multicore available function’s help (important part disclosure widget ?supportsMulticore) R supports forked processing Unix-like operating system Linux macOS, Microsoft Windows operating system. R environments considered unstable perform parallel processing based forking. example case using RStudio, cf. RStudio Inc. recommends using forked processing running R within RStudio software. function detects running environment returns FALSE, despite underlying operating system supports forked processing. warning also produced informing user first time time function called R session. warning can disabled setting R option parallelly.supportsMulticore.unstable, environment variable R_PARALLELLY_SUPPORTSMULTICORE_UNSTABLE \"quiet\". possible disable forked processing futures setting R option parallelly.fork.enable FALSE.  Alternatively, one can set environment variable R_PARALLELLY_FORK_ENABLE false. Analogously, possible override disabled forking setting one TRUE. nutshell, multicore unavailable Windows discouraged (considered unstable) R environments, notably RStudio always used Unix-like operating systems options(parallelly.fork.enable = TRUE) main reason using multicore FORKing considered faster result lower memory overhead PSOCK (.e. multisession) (see technical details) Furthermore, DoIntegrate() uses future, also NSE (non-standard evaluation), enabling specify arguments within integration function call. Briefly, call inside DoIntegrate() (DoIntegrate(bbknnIntegration())) directly executed captured executed later (proper value object parameter can passed bbknnIntegration instance). details available book Advanced R Hadley Wickham. important part , unlike multicore, multisession future, DoIntegrate() evaluates argument launching integration background R session. Thus, Seurat Assay object passed structure (output str(object)). takes time makes call extremely long. unexpected side-effect. slows CCAIntegration RPCAIntegration lot input Seurat objects normalised SCTransform(). Indeed, call FindIntegrationAnchors() -> merge() -> merge.SCTAssay(). latter performs grep previous calls (output sys.calls()). multisession future, big objects Seurat Assay object passed structure grep can unnecessarily time-consuming. avoid , one can either specify use.future = FALSE R-based method (always preferable) least ban use CCA RPCA integrations multisession future (note Windows users can pick first option).","code":"parallelly::supportsMulticore() ## [1] FALSE help('supportsMulticore', package = 'parallelly')"},{"path":"https://fspecque.github.io/test/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Florian Specque. Author, maintainer. Domitille Chalopin. Author. Macha Nikolski. Reviewer. Aurélien Barré. Contributor. Centre de Bioinformatique de Bordeaux (CBiB). Copyright holder.","code":""},{"path":"https://fspecque.github.io/test/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Specque F, Chalopin D (2025). SeuratIntegrate: Expands set integration methods available Seurat. R package version 0.4.0, https://cbib.github.io/Seurat-Integrate/, https://fspecque.github.io/test/, https://github.com/cbib/Seurat-Integrate.","code":"@Manual{,   title = {SeuratIntegrate: Expands the set of integration methods available to Seurat},   author = {Florian Specque and Domitille Chalopin},   year = {2025},   note = {R package version 0.4.0, https://cbib.github.io/Seurat-Integrate/, https://fspecque.github.io/test/},   url = {https://github.com/cbib/Seurat-Integrate}, }"},{"path":"https://fspecque.github.io/test/index.html","id":"seuratintegrate","dir":"","previous_headings":"","what":"Expands the set of integration methods available to Seurat","title":"Expands the set of integration methods available to Seurat","text":"SeuratIntegrate streamlines single-cell transcriptomics (scRNA-seq) data integration batch effect correction. R package effortlessly extends Seurat workflow 8 popular integration methods across R Python, complemented 11 robust scoring metrics estimate performance. Integrations ComBat Harmony MNN BBKNN scVI scANVI Scanorama trVAE Scoring metrics ARI ASW Batch ASW Cell cycle conservation Graph connectivity PCA-density PCA-regression kBET cell-type (c)LISI batch ()LISI NMI","code":""},{"path":"https://fspecque.github.io/test/index.html","id":"installation","dir":"","previous_headings":"","what":"Installation","title":"Expands the set of integration methods available to Seurat","text":"Install SeuratIntegrate github: benefit SeuratIntegrate’s full capabilities, recommend installing following packages:","code":"install.packages(c(\"remotes\", \"BiocManager\")) # if not installed  remotes::install_github(\"cbib/Seurat-Integrate\", repos = BiocManager::repositories()) # fast distance computation install.packages('distances')  # required to test for k-nearest neighbour batch effects remotes::install_github('theislab/kBET')  # faster Local Inverse Simpson’s Index computation remotes::install_github('immunogenomics/lisi')"},{"path":"https://fspecque.github.io/test/index.html","id":"conda-environments-for-python-methods","dir":"","previous_headings":"","what":"Conda environments for Python methods","title":"Expands the set of integration methods available to Seurat","text":"simplify creation management conda environments, suggest using UpdateEnvCache(): environments saved automatically used Python integration methods provided SeuratIntegrate. Alternatively, cache can updated pre-existing environment. can useful set conda environment command failed conda environment turned non-functional. cache remains persistent across sessions state can displayed : details provided vignette(\"setup_and_tips\").","code":"# create environments: UpdateEnvCache(\"bbknn\") UpdateEnvCache(\"scvi\") UpdateEnvCache(\"scanorama\") UpdateEnvCache(\"trvae\") # save \"my_bbknn_env\" (for bbknn) to cache UpdateEnvCache(\"bbknn\", conda.env = \"my_bbknn_env\") getCache()"},{"path":"https://fspecque.github.io/test/index.html","id":"data-integration","dir":"","previous_headings":"","what":"Data integration","title":"Expands the set of integration methods available to Seurat","text":"run integration algorithms, developed function called DoIntegrate() enables: performing multiple integration methods single call control data (raw, normalised scaled) features use input flexible customisation parameters integration method , integration methods use variable features input, exception scVIIntegration() set use features. CombatIntegration() correct normalised counts, scVIIntegration() train raw counts. use.future must TRUE Python methods, FALSE R methods. Integration methods produce one several outputs. can multiple types - either new assay corrected counts, new dimension reduction corrected cell embeddings, new graph corrected edges. type output important consider, require different post-processing steps result integration can visualised UMAP: Corrected counts: ScaleData() -> RunPCA() -> RunUMAP() Dimension reduction: RunUMAP() KNN graph: RunUMAP(umap.method = \"umap-learn\")","code":"seu <- DoIntegrate(seu,        # ... integrations          CombatIntegration(layers = \"data\"),          HarmonyIntegration(orig = \"pca\", dims = 1:30),          ScanoramaIntegration(ncores = 4L, layers = \"data\"),          scVIIntegration(layers = \"counts\", features = Features(seu)),        # ...        use.hvg = TRUE,    # `VariableFeatures()`        use.future = c(FALSE, FALSE, TRUE, TRUE) )"},{"path":"https://fspecque.github.io/test/index.html","id":"scoring","dir":"","previous_headings":"","what":"Scoring","title":"Expands the set of integration methods available to Seurat","text":"SeuratIntegrate incorporates 11 scoring metrics: 6 quantify degree batch mixing (batch correction), 5 assess preservation biological differences (bio-conservation) based ground truth cell type labels. score can obtained using function form Score[score_name](), directly saved Seurat object using AddScore[score_name]() counterpart: AddScore functions advantage Score functions. allow scale scores zero one standardize direction (closer one, always better), improving interpretability. , scores can plotted readily compare different integrations:","code":"# save the score in a variable rpca_score <- ScoreRegressPC(seu, reduction = \"pca\")  # or save the score in the Seurat object seu <- AddScoreRegressPC(seu, integration = \"unintegrated\", reduction = \"pca\") # scale seu <- ScaleScores(seu)  # plot PlotScores(seu)"},{"path":"https://fspecque.github.io/test/reference/CellCycleScoringPerBatch.html","id":null,"dir":"Reference","previous_headings":"","what":"Score cell cycle phases per batch — CellCycleScoringPerBatch","title":"Score cell cycle phases per batch — CellCycleScoringPerBatch","text":"Assign cell cycle scores cells. Scores computed batch independantly.","code":""},{"path":"https://fspecque.github.io/test/reference/CellCycleScoringPerBatch.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Score cell cycle phases per batch — CellCycleScoringPerBatch","text":"","code":"CellCycleScoringPerBatch(   object,   batch.var = NULL,   s.features,   g2m.features,   ctrl = NULL,   assay = NULL,   layer = NULL,   ... )"},{"path":"https://fspecque.github.io/test/reference/CellCycleScoringPerBatch.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Score cell cycle phases per batch — CellCycleScoringPerBatch","text":"object Seurat object batch.var name batch variable (must object metadata) s.features vector features associated S phase g2m.features vector features associated G2M phase ctrl Number control features selected bin per analyzed feature supplied AddModuleScore. Defaults value equivalent minimum number features present 's.features' 'g2m.features'. assay assay use. Passed Seurat automatically construct batch.var provided. Useless otherwise layer layer use. Passed Seurat automatically construct batch.var provided. Useless otherwise ... Arguments passed CellCycleScoring, AddModuleScore (exception set.ident always FALSE)","code":""},{"path":"https://fspecque.github.io/test/reference/CellCycleScoringPerBatch.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Score cell cycle phases per batch — CellCycleScoringPerBatch","text":"Seurat object following columns added object meta data: S.Score, G2M.Score, Phase","code":""},{"path":[]},{"path":"https://fspecque.github.io/test/reference/CellCycleScoringPerBatch.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Score cell cycle phases per batch — CellCycleScoringPerBatch","text":"","code":"if (FALSE) { # \\dontrun{ obj <- SeuratData::LoadData(\"pbmcsca\") obj[[\"RNA\"]] <- split(obj[[\"RNA\"]], f = obj$Method) obj <- NormalizeData(obj) obj <- FindVariableFeatures(obj) obj <- ScaleData(obj) obj <- CellCycleScoringPerBatch(obj, batch.var = 'Method',                                 s.features = cc.genes.updated.2019$s.genes,                                 g2m.features = cc.genes.updated.2019$g2m.genes)  head(obj[[]]) } # }"},{"path":"https://fspecque.github.io/test/reference/CombatIntegration.html","id":null,"dir":"Reference","previous_headings":"","what":"Run ComBat on Seurat's Assay5 object through IntegrateLayers — CombatIntegration","title":"Run ComBat on Seurat's Assay5 object through IntegrateLayers — CombatIntegration","text":"wrapper run ComBat ComBat_seq multi-layered Seurat V5 object","code":""},{"path":"https://fspecque.github.io/test/reference/CombatIntegration.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Run ComBat on Seurat's Assay5 object through IntegrateLayers — CombatIntegration","text":"","code":"CombatIntegration(   object,   orig = NULL,   groups = NULL,   groups.name = NULL,   layers = \"data\",   scale.layer = \"scale.data\",   features = NULL,   reconstructed.assay = \"combat.reconstructed\",   key.assay = \"combat_\",   combat.function = c(\"combat\", \"combat_seq\"),   use.scaled = FALSE,   verbose = TRUE,   ... )"},{"path":"https://fspecque.github.io/test/reference/CombatIntegration.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Run ComBat on Seurat's Assay5 object through IntegrateLayers — CombatIntegration","text":"object Seurat object (Assay5 object called IntegrateLayers) orig DimReduc object. set directly called IntegrateLayers, use orig.reduction argument instead groups named data frame grouping information. Preferably one-column groups.name = NULL groups.name Column name groups data frame stores grouping information. groups.name = NULL, first column used layers Name layers use integration scale.layer Name scaled layer Assay features Vector feature names input integration method. features = NULL (default), VariableFeatures used. pass features, use output Features() reconstructed.assay Name assay containing corrected expression matrix key.assay Optional key new combat assay. Format: \"[:alnum:]*_\" combat.function ComBat implementation use. One combat, combat_seq. Note ComBat_seq improved model ComBat requires dense matrix. Sparse dense matrix conversion can memory-intensive. use.scaled default layer passed layer argument used. use.scaled = TRUE, scale.layer input ComBat. verbose Print messages. Set FALSE disable ... Additional arguments passed ComBat ComBat_seq.","code":""},{"path":"https://fspecque.github.io/test/reference/CombatIntegration.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Run ComBat on Seurat's Assay5 object through IntegrateLayers — CombatIntegration","text":"function returns list containing: new Assay name reconstructed.assay (key set   assay.key) corrected cell counts. called via IntegrateLayers, Seurat object new assay returned","code":""},{"path":"https://fspecque.github.io/test/reference/CombatIntegration.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Run ComBat on Seurat's Assay5 object through IntegrateLayers — CombatIntegration","text":"function requires sva (Surrogate Variable Analysis) package installed","code":""},{"path":"https://fspecque.github.io/test/reference/CombatIntegration.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Run ComBat on Seurat's Assay5 object through IntegrateLayers — CombatIntegration","text":"Johnson, W. E., Li, C. & Rabinovic, . Adjusting batch effects microarray expression data using empirical Bayes methods. Biostatistics 8, 118–127 (2006). DOI Zhang, Y., Parmigiani, G. & Johnson, W. E. ComBat-seq: batch effect adjustment RNA-seq count data. NAR Genomics Bioinformatics 2 (2020). DOI","code":""},{"path":"https://fspecque.github.io/test/reference/CombatIntegration.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Run ComBat on Seurat's Assay5 object through IntegrateLayers — CombatIntegration","text":"","code":"if (FALSE) { # \\dontrun{ # Preprocessing obj <- UpdateSeuratObject(SeuratData::LoadData(\"pbmcsca\")) obj[[\"RNA\"]] <- split(obj[[\"RNA\"]], f = obj$Method) obj <- NormalizeData(obj) obj <- FindVariableFeatures(obj) obj <- ScaleData(obj) obj <- RunPCA(obj)  # After preprocessing, we integrate layers based on the \"Method\" variable: obj <- IntegrateLayers(object = obj, method = CombatIntegration,                        verbose = TRUE, layers = \"data\", scale.layer = NULL,                        features = VariableFeatures(                          FindVariableFeatures(obj, nfeatures = 5e3)                        ))  # We can also change parameters such as the input data. # Here we use the scale data, the ComBat implementation and we use the cell # labels as a \"biological condition of interest\" (/!\\ long):  obj <- IntegrateLayers(object = obj,  method = CombatIntegration,                        verbose = TRUE, features = VariableFeatures(obj),                        use.scaled = FALSE, combat.function = 'combat_seq',                        group = obj[[]]$CellType, groups = obj[[]],                        groups.name = \"Method\", layers = \"counts\") } # }"},{"path":"https://fspecque.github.io/test/reference/CondaEnv-class.html","id":null,"dir":"Reference","previous_headings":"","what":"Encapsulates information about a conda environment — CondaEnv-class","title":"Encapsulates information about a conda environment — CondaEnv-class","text":"CondaEnv class provides basic structure store information conda environment given method. designed used CondaEnvManager class.","code":""},{"path":"https://fspecque.github.io/test/reference/CondaEnv-class.html","id":"slots","dir":"Reference","previous_headings":"","what":"Slots","title":"Encapsulates information about a conda environment — CondaEnv-class","text":"method 1-length character. Indicating method CondaEnv refers needs.conda logical. Whether method needs conda (yes python-based, R-based) conda.bin single string. path conda binary. empty (\"\"), NULL \"conda\", \"auto\" passed conda_binary find path conda binary PATH conda.env.name 1-length character. Name conda environment conda.env.path 1-length character. Path conda environment .valid logical. Whether environment valid. set user. Set checkCondaEnv.","code":""},{"path":[]},{"path":"https://fspecque.github.io/test/reference/CondaEnv.html","id":null,"dir":"Reference","previous_headings":"","what":"Handy CondaEnv instance constructor — CondaEnv","title":"Handy CondaEnv instance constructor — CondaEnv","text":"Wrapper create CondaEnv object meant store information single conda environment specific method. cases, best user favors CondaEnvManager-related functions.","code":""},{"path":"https://fspecque.github.io/test/reference/CondaEnv.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Handy CondaEnv instance constructor — CondaEnv","text":"","code":"CondaEnv(   method = known.methods,   conda.bin = NULL,   conda.env.name = NULL,   conda.env.path = NULL )"},{"path":"https://fspecque.github.io/test/reference/CondaEnv.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Handy CondaEnv instance constructor — CondaEnv","text":"method method name. One \"combat\", \"harmony\", \"mnn\", \"bbknn\", \"scvi\", \"scanvi\", \"scanorama\" conda.bin path conda binary. empty (\"\"), NULL \"conda\", \"auto\" passed conda_binary() find path conda binary PATH conda.env.name name conda environment conda.env.path path conda environment","code":""},{"path":"https://fspecque.github.io/test/reference/CondaEnv.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Handy CondaEnv instance constructor — CondaEnv","text":"CondaEnv object","code":""},{"path":[]},{"path":"https://fspecque.github.io/test/reference/CondaEnvManager-class.html","id":null,"dir":"Reference","previous_headings":"","what":"Manager of conda environments for python-based integration methods — CondaEnvManager-class","title":"Manager of conda environments for python-based integration methods — CondaEnvManager-class","text":"CondaEnvManager class provides handy way set , store use conda environments python-based integration methods. designed set modified via helper functions, directly user.","code":""},{"path":"https://fspecque.github.io/test/reference/CondaEnvManager-class.html","id":"slots","dir":"Reference","previous_headings":"","what":"Slots","title":"Manager of conda environments for python-based integration methods — CondaEnvManager-class","text":"combat CondaEnv. R-based combat method, nothing set . harmony CondaEnv. R-based harmony method, nothing set . mnn CondaEnv. R-based MNN method, nothing set . bbknn CondaEnv. python-based bbknn method. scvi CondaEnv. python-based SCVI method. Can shared SCANVI. scanvi CondaEnv. python-based SCANVI method. Can shared SCVI. scanorama CondaEnv. python-based Scanorama method trvae CondaEnv. python-based trVAE method","code":""},{"path":[]},{"path":"https://fspecque.github.io/test/reference/CondaManager.html","id":null,"dir":"Reference","previous_headings":"","what":"Handy CondaEnvManger instance constructor — CondaManager","title":"Handy CondaEnvManger instance constructor — CondaManager","text":"Wrapper create CondaEnvManager object meant store information conda environments known methods data.frame object (typically stored package's cache). cases, best user favors UpdateEnvCache() function enables create/overwrite conda environments update package's internal cache.","code":""},{"path":"https://fspecque.github.io/test/reference/CondaManager.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Handy CondaEnvManger instance constructor — CondaManager","text":"","code":"CondaManager(cache)"},{"path":"https://fspecque.github.io/test/reference/CondaManager.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Handy CondaEnvManger instance constructor — CondaManager","text":"cache correctly formatted (see ) data.frame path data.frame stored inside RDS file. cache missing, return blank object (.e. uninitialized state).","code":""},{"path":"https://fspecque.github.io/test/reference/CondaManager.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Handy CondaEnvManger instance constructor — CondaManager","text":"CondaEnvManager object","code":""},{"path":"https://fspecque.github.io/test/reference/CondaManager.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Handy CondaEnvManger instance constructor — CondaManager","text":"cache data.frame's expected column names : method needs.conda conda.bin.value conda.bin.valid conda.env.name.value conda.env.name.valid conda.env.path.value conda.env.path.valid .valid","code":""},{"path":[]},{"path":"https://fspecque.github.io/test/reference/CutKnn.html","id":null,"dir":"Reference","previous_headings":"","what":"Remove excessive number of neighbours in a knn graph — CutKnn","title":"Remove excessive number of neighbours in a knn graph — CutKnn","text":"Ensure cell's number neighbours exceed cutoff","code":""},{"path":"https://fspecque.github.io/test/reference/CutKnn.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Remove excessive number of neighbours in a knn graph — CutKnn","text":"","code":"CutKnn(   object,   graph.name,   new.graph = NULL,   k.max,   assay = NULL,   verbose = TRUE )"},{"path":"https://fspecque.github.io/test/reference/CutKnn.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Remove excessive number of neighbours in a knn graph — CutKnn","text":"object Seurat object graph.name name Graph Neighbor instance stored Seurat object. new.graph name trimmed graph save Seurat object k.max maximum number neigbours allowed per cell assay name assay use. Ignored graph object Neighbor object. specified (default), default assay used verbose whether print messages. Set FALSE disable","code":""},{"path":"https://fspecque.github.io/test/reference/CutKnn.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Remove excessive number of neighbours in a knn graph — CutKnn","text":"Seurat object new Graph Neighbor instance","code":""},{"path":"https://fspecque.github.io/test/reference/DoIntegrate.html","id":null,"dir":"Reference","previous_headings":"","what":"Integrate layers using one or multiple integration method(s) — DoIntegrate","title":"Integrate layers using one or multiple integration method(s) — DoIntegrate","text":"Integrate layers Seurat object using one integration methods. Available integration methods listed bottom page. DoIntegrate() works best SeuratIntegrate's methods.","code":""},{"path":"https://fspecque.github.io/test/reference/DoIntegrate.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Integrate layers using one or multiple integration method(s) — DoIntegrate","text":"","code":"DoIntegrate(   object,   ...,   use.hvg = TRUE,   use.future = TRUE,   future.globals.size = getOption(\"future.globals.maxSize\") )"},{"path":"https://fspecque.github.io/test/reference/DoIntegrate.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Integrate layers using one or multiple integration method(s) — DoIntegrate","text":"object Seurat object ... one integration method call(s) correct batch effects . Must form package::MethodIntegration(). recommended use :: safer case namespace collision package attached loaded. forget parentheses. use.hvg whether use highly variable genes. FALSE causes features present assay used. use.future whether use future run integrations background session. Useful python-based algorithms invoked. future.globals.size maximum allowed size (bytes) global variables export. default, uses value option \"future.globals.maxSize\". NULL, thrice size Seurat object used. Inoperative use.future = FALSE","code":""},{"path":"https://fspecque.github.io/test/reference/DoIntegrate.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Integrate layers using one or multiple integration method(s) — DoIntegrate","text":"updated Seurat object enriched integration methods' outputs.","code":""},{"path":"https://fspecque.github.io/test/reference/DoIntegrate.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Integrate layers using one or multiple integration method(s) — DoIntegrate","text":"call integration method require parentheses. Parameter values specific method can enclosed brackets, although defaults arguments good enough cases. Note integration method, argument values specified call supersede DoIntegrate's internal computations. instance, forces ComBat CCA use features instead variable ones.","code":"DoIntegrate(seu,             SeuratIntegrate::CombatIntegration(features = Features(seu)),             Seurat::CCAIntegration(),             use.hvg = TRUE)"},{"path":"https://fspecque.github.io/test/reference/DoIntegrate.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Integrate layers using one or multiple integration method(s) — DoIntegrate","text":"desired value parameters use.hvg, use.future future.globals.size can different method called. Hence, accept vectors one element. must order integration method calls. unconventional way calling methods presents advantages: single call DoIntegrate, can perform multiple integrations , preserving flexibility individual method call fine-tuning integration-specific parameters.","code":""},{"path":"https://fspecque.github.io/test/reference/DoIntegrate.html","id":"integration-method-functions","dir":"Reference","previous_headings":"","what":"Integration Method Functions","title":"Integrate layers using one or multiple integration method(s) — DoIntegrate","text":"following integration method functions available: SeuratIntegrate::bbknnIntegration SeuratIntegrate::CombatIntegration SeuratIntegrate::HarmonyIntegration SeuratIntegrate::HarmonyIntegration.fix SeuratIntegrate::MNNIntegration SeuratIntegrate::ScanoramaIntegration SeuratIntegrate::scANVIIntegration SeuratIntegrate::scVIIntegration SeuratIntegrate::scVIIntegration.fix SeuratIntegrate::trVAEIntegration CCAIntegration HarmonyIntegration JointPCAIntegration RPCAIntegration","code":""},{"path":"https://fspecque.github.io/test/reference/ExpandNeighbours.html","id":null,"dir":"Reference","previous_headings":"","what":"Expand knn graph to increase the number of neighbours — ExpandNeighbours","title":"Expand knn graph to increase the number of neighbours — ExpandNeighbours","text":"Expand knn graph increase number nearest neighbours using Dijkstra's algorithm, diffusion algorithm. Dijkstra's algorithm used prepare LISI score, diffusion suited preparing compute kBET score. Beware diffusion designed work connectivity matrices adequate distance-based networks.","code":""},{"path":"https://fspecque.github.io/test/reference/ExpandNeighbours.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Expand knn graph to increase the number of neighbours — ExpandNeighbours","text":"","code":"ExpandNeighbours(   object,   graph.name = \"RNA_nn\",   new.graph.name = NULL,   graph.type = c(\"distances\", \"connectivities\"),   k.target = 90L,   do.symmetrize = FALSE,   algo = c(\"dijkstra\", \"diffusion\"),   which.dijkstra = c(\"auto\", \"igraph\", \"fast\", \"slow\"),   dijkstra.ncores = 1L,   dijkstra.tol = 1L,   diffusion.iter = 26L,   assay = NULL,   verbose = TRUE )  # S4 method for class 'Seurat' ExpandNeighbours(   object,   graph.name = \"RNA_nn\",   new.graph.name = NULL,   graph.type = c(\"distances\", \"connectivities\"),   k.target = 90L,   do.symmetrize = FALSE,   algo = c(\"dijkstra\", \"diffusion\"),   which.dijkstra = c(\"auto\", \"igraph\", \"fast\", \"slow\"),   dijkstra.ncores = 1L,   dijkstra.tol = 1L,   diffusion.iter = 26L,   assay = NULL,   verbose = TRUE )"},{"path":"https://fspecque.github.io/test/reference/ExpandNeighbours.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Expand knn graph to increase the number of neighbours — ExpandNeighbours","text":"object Seurat, Graph Neighbor object graph.name name Graph Neighbor instance stored Seurat object. new.graph.name name return Graph store Seurat object. graph.type One \"distances\" \"connectivities\", indicating type metric stored graph object. k.target number nearest neighbours reach .symmetrize whether make input graph symmetric necessary. See Details section explanations algo One \"dijkstra\" \"diffusion\". \"diffusion\" suited connectivity matrices .dijkstra one \"igraph\", \"fast\" \"slow\". \"auto\" (default) chooses . See Details section dijkstra.ncores number cores use Dijkstra's algorithm. Ignored .dijkstra = \"igraph\" dijkstra.tol number sequential iterations identical best neighbours found consider Dijkstra's algorithm stopped. Ignored .dijkstra = \"igraph\" diffusion.iter maximum number iterations reach k.target assay name assay store output Graph verbose whether print progress messages","code":""},{"path":"https://fspecque.github.io/test/reference/ExpandNeighbours.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Expand knn graph to increase the number of neighbours — ExpandNeighbours","text":"Seurat object new Graph instance dgCMatrix representing Graph ","code":""},{"path":"https://fspecque.github.io/test/reference/ExpandNeighbours.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Expand knn graph to increase the number of neighbours — ExpandNeighbours","text":"approximate nature nearest neighbour search algorithm used compute knn graph makes resulting adjacency matrix asymmetric. means \\(cell_i\\) can nearest neighbour \\(cell_j\\) reverse true even though distance \\(cell_i\\) \\(cell_j\\) lower distance \\(cell_j\\) nearest neighbours. One can choose keep graph consider directed graph (.symmetrize = FALSE). alternative solution use computed distances extend knn graph making matrix symmetric. Note connectivity graphs already symmetric, argument value effect result.","code":""},{"path":"https://fspecque.github.io/test/reference/FindOptimalClusters.html","id":null,"dir":"Reference","previous_headings":"","what":"Find a clustering that maximises NMI or ARI — FindOptimalClusters","title":"Find a clustering that maximises NMI or ARI — FindOptimalClusters","text":"Compute clusters multiple resolutions saves metadata clustering result reaches maximum NMI /ARI value given cell-type label variable.","code":""},{"path":"https://fspecque.github.io/test/reference/FindOptimalClusters.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Find a clustering that maximises NMI or ARI — FindOptimalClusters","text":"","code":"FindOptimalClusters(   object,   graph.name = NULL,   cell.var = NULL,   cluster.name = \"{graph.name}_{cell.var}_{metric}\",   modularity.fxn = 1,   initial.membership = NULL,   node.sizes = NULL,   resolutions = seq(from = 0.1, to = 2, by = 0.1),   optimisation.metric = c(\"nmi\", \"ari\"),   method = \"matrix\",   algorithm = 1,   n.start = 10,   n.iter = 10,   random.seed = 0,   group.singletons = TRUE,   temp.file.location = NULL,   edge.file.name = NULL,   verbose = TRUE,   ... )"},{"path":"https://fspecque.github.io/test/reference/FindOptimalClusters.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Find a clustering that maximises NMI or ARI — FindOptimalClusters","text":"object Seurat object graph.name name knn graph score. cell.var name(s) column(s) cell type label variable (must object metadata). Multiple column names accepted cluster.name (optionally 'glue') string used new metadata column name (see Details section) modularity.fxn Modularity function (1 = standard; 2 = alternative). initial.membership, node.sizes Parameters pass Python leidenalg function. resolutions resolutions compute clusters optimisation.metric one \"nmi\" \"ari\" (default). metric(s) use check clustering results cell.var. method Method running leiden (defaults matrix fast small datasets). Enable method = \"igraph\" avoid casting large data dense matrix. algorithm Algorithm modularity optimization (1 = original Louvain algorithm; 2 = Louvain algorithm multilevel refinement; 3 = SLM algorithm; 4 = Leiden algorithm). Leiden requires leidenalg python. n.start Number random starts. n.iter Maximal number iterations per random start. random.seed Seed random number generator. group.singletons Group singletons nearest cluster. FALSE, assign singletons \"singleton\" group temp.file.location Directory intermediate files written. Specify ABSOLUTE path. edge.file.name Edge file use input modularity optimizer jar. verbose Print output ... Arguments passed methods","code":""},{"path":"https://fspecque.github.io/test/reference/FindOptimalClusters.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Find a clustering that maximises NMI or ARI — FindOptimalClusters","text":"updated seurat object new metadata column(s)","code":""},{"path":"https://fspecque.github.io/test/reference/FindOptimalClusters.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Find a clustering that maximises NMI or ARI — FindOptimalClusters","text":"cluster.name can use 'glue' syntax avoid overwriting metadata columns multiple metrics /cell-type label variables provided. can ignored otherwise. Injectable variables \"graph.name\", \"cell.var\" \"metric\" (\"optimisation.metric\"). must flanked single curly brackets (\"{\" \"}\"). instance, prefer name clusters integration instead graph.name, use glue syntax (e.g. \"combat_{cell.var}_{metric}\" work, \"{combat}_{cell.var}_{metric}\" \"{integration}_{cell.var}_{metric}\" throw error)","code":""},{"path":"https://fspecque.github.io/test/reference/FindOptimalClusters.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Find a clustering that maximises NMI or ARI — FindOptimalClusters","text":"Luecken, M. D., Büttner, M., Chaichoompu, K., Danese, ., Interlandi, M., Mueller, M. F., Strobl, D. C., Zappia, L., Dugas, M., Colomé-Tatché, M. & Theis, F. J. Benchmarking atlas-level data integration single-cell genomics. Nat Methods 19, 41–50 (2021). DOI","code":""},{"path":[]},{"path":"https://fspecque.github.io/test/reference/GetConnectivities.html","id":null,"dir":"Reference","previous_headings":"","what":"Derive connectivities from distances — GetConnectivities","title":"Derive connectivities from distances — GetConnectivities","text":"Adapted scanpy's strategy sc.pp.neighbors() compute connectivities. Two methods available, using Gaussian kernel fuzzy union simplical sets implemented umap-learn","code":""},{"path":"https://fspecque.github.io/test/reference/GetConnectivities.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Derive connectivities from distances — GetConnectivities","text":"","code":"GetConnectivities(   object,   neighbors.use,   method = c(\"umap\", \"gauss\"),   graph.name = NULL,   assay = NULL,   umap.set.op.mix.ratio = 1,   umap.local.connectivity = 1,   umap.niter.smoothing = 64L,   umap.apply.set.operations = TRUE,   umap.bipartite = FALSE,   gauss.sigmas = NULL,   gauss.median.sigma = FALSE,   verbose = TRUE )"},{"path":"https://fspecque.github.io/test/reference/GetConnectivities.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Derive connectivities from distances — GetConnectivities","text":"object Seurat object neighbors.use name Neighbor instance stored Seurat object derive connectivities . method one \"umap\" \"gauss\". Decides whether connectivities computed using  fuzzy union simplical sets (\"umap\") Gaussian kernel (\"gauss\") graph.name name return Graph connectivities store Seurat object. assay name assay reference output Graph object. Use default assay object provided. umap.set.op.mix.ratio float 0 1. Controls fuzzy sets mixed obtain global fuzzy simplicial set. 0 1 correspond pure fuzzy intersection union, respectively. fuzzy set operations use product t-norm. applies umap method. umap.local.connectivity local connectivity required, .e. expected number nearest neighbours locally connected. higher, local connections output. practice, local intrinsic dimension manifold. applies umap method umap.apply.set.operations = TRUE. umap.niter.smoothing maximum number iterations smoothing process distances. applies umap method. umap.apply.set.operations set FALSE disable fuzzy union intersection local fuzzy simplicial sets global fuzzy simplicial set. applies umap method. umap.bipartite whether knn network bipartite (FALSE default). applies umap method. gauss.sigmas default, sigma value (.e. width kernel) per cell computed internally. sigmas controlling cell's connectivities range magnitude. Alternatively, can provide width(s). length sigmas shorter number cells, recycled. applies Gaussian method. gauss.median.sigma estimation method use sigmas = NULL. default, use cell’s distance kth nearest neighbour. median.sigma = TRUE, use median distances nearest neighbours (excluding self). applies Gaussian method. verbose whether print progress messages","code":""},{"path":"https://fspecque.github.io/test/reference/GetConnectivities.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Derive connectivities from distances — GetConnectivities","text":"Seurat object new Graph instance name graph.name","code":""},{"path":"https://fspecque.github.io/test/reference/GetConnectivities.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Derive connectivities from distances — GetConnectivities","text":"UMAP method re-implementation function fuzzy_simplicial_set() umap-learn estimate identical connectivities. can check original documentation. Gaussian kernel method re-implementation analogous function scanpy called sc.pp.neighbors(). can look original functionmedian.sigmas = FALSE method used Haghverdi L. et al.,2016.","code":""},{"path":"https://fspecque.github.io/test/reference/GetConnectivities.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Derive connectivities from distances — GetConnectivities","text":"McInnes, L., Healy, J. & Melville, J. UMAP: Uniform Manifold Approximation Projection Dimension Reduction. arXiv preprint (2018). DOI Wolf, F. ., Angerer, P. & Theis, F. J. SCANPY: large-scale single-cell gene expression data analysis. Genome Biology 19, (2018). Coifman, R. R., Lafon, S., Lee, . B., Maggioni, M., Nadler, B., Warner, F. & Zucker, S. W. Geometric diffusions tool harmonic analysis structure definition data: Diffusion maps. PNAS 102, 7426–7431 (2005). DOI Haghverdi, L., Büttner, M., Wolf, F. ., Buettner, F. & Theis, F. J. Diffusion pseudotime robustly reconstructs lineage branching. Nature Methods 13, 845–848 (2016). DOI","code":""},{"path":"https://fspecque.github.io/test/reference/GetNeighborsPerBatch.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate number of nearest neighbours between batches — GetNeighborsPerBatch","title":"Calculate number of nearest neighbours between batches — GetNeighborsPerBatch","text":"Calculate number nearest neighbours batches knn graph","code":""},{"path":"https://fspecque.github.io/test/reference/GetNeighborsPerBatch.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate number of nearest neighbours between batches — GetNeighborsPerBatch","text":"","code":"GetNeighborsPerBatch(   object,   batch.var,   graph.name = \"RNA_nn\",   count.self = TRUE )  # S4 method for class 'Seurat,character' GetNeighborsPerBatch(   object,   batch.var,   graph.name = \"RNA_nn\",   count.self = TRUE )"},{"path":"https://fspecque.github.io/test/reference/GetNeighborsPerBatch.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculate number of nearest neighbours between batches — GetNeighborsPerBatch","text":"object Seurat object batch.var name column Seurat object's metadata containing batch information graph.name name Graph Neighbor instance stored object. available, prefer distance based network connectivities graph (especially computed UMAP method). count.self whether include self--self vertices calculation","code":""},{"path":"https://fspecque.github.io/test/reference/GetNeighborsPerBatch.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calculate number of nearest neighbours between batches — GetNeighborsPerBatch","text":"square count matrix size number batches (see Details section)","code":""},{"path":"https://fspecque.github.io/test/reference/GetNeighborsPerBatch.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Calculate number of nearest neighbours between batches — GetNeighborsPerBatch","text":"output matrix likely symmetrical. due approximate nature nearest neighbour search algorithm used compute knn graph. must read row. instance, number times cells batch 1 cells batch 3 nn matrix[1,3]","code":""},{"path":[]},{"path":"https://fspecque.github.io/test/reference/GetPropInterBatch.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate proportion of nearest neighbours between batches — GetPropInterBatch","title":"Calculate proportion of nearest neighbours between batches — GetPropInterBatch","text":"Calculate proportion nearest neighbours batches knn graph","code":""},{"path":"https://fspecque.github.io/test/reference/GetPropInterBatch.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate proportion of nearest neighbours between batches — GetPropInterBatch","text":"","code":"GetPropInterBatch(   object,   batch.var,   graph.name = \"RNA_nn\",   count.self = TRUE,   per.batch = TRUE )"},{"path":"https://fspecque.github.io/test/reference/GetPropInterBatch.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculate proportion of nearest neighbours between batches — GetPropInterBatch","text":"object Seurat object batch.var name column Seurat object's metadata containing batch information graph.name name Graph Neighbor instance stored object. available, prefer distance based network connectivities graph (especially computed UMAP method). count.self whether include self--self vertices calculation per.batch whether keep proportions per batch aggregate everything","code":""},{"path":"https://fspecque.github.io/test/reference/GetPropInterBatch.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calculate proportion of nearest neighbours between batches — GetPropInterBatch","text":"vector length 1 number batches, depending per.batch argument value","code":""},{"path":[]},{"path":"https://fspecque.github.io/test/reference/GetPropIntraBatch.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate proportion of nearest neighbours within batches — GetPropIntraBatch","title":"Calculate proportion of nearest neighbours within batches — GetPropIntraBatch","text":"Calculate proportion nearest neighbours within batches knn graph","code":""},{"path":"https://fspecque.github.io/test/reference/GetPropIntraBatch.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate proportion of nearest neighbours within batches — GetPropIntraBatch","text":"","code":"GetPropIntraBatch(   object,   batch.var,   graph.name = \"RNA_nn\",   count.self = TRUE,   per.batch = TRUE )"},{"path":"https://fspecque.github.io/test/reference/GetPropIntraBatch.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculate proportion of nearest neighbours within batches — GetPropIntraBatch","text":"object Seurat object batch.var name column Seurat object's metadata containing batch information graph.name name Graph Neighbor instance stored object. available, prefer distance based network connectivities graph (especially computed UMAP method). count.self whether include self--self vertices calculation per.batch whether keep proportions per batch aggregate everything","code":""},{"path":"https://fspecque.github.io/test/reference/GetPropIntraBatch.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calculate proportion of nearest neighbours within batches — GetPropIntraBatch","text":"vector length 1 number batches, depending per.batch argument value","code":""},{"path":[]},{"path":"https://fspecque.github.io/test/reference/HarmonyIntegration.html","id":null,"dir":"Reference","previous_headings":"","what":"Run Harmony on Seurat's Assay5 object through IntegrateLayers — HarmonyIntegration","title":"Run Harmony on Seurat's Assay5 object through IntegrateLayers — HarmonyIntegration","text":"wrapper run Harmony multi-layered Seurat V5 object Can called via SeuratIntegrate::HarmonyIntegration() HarmonyIntegration.fix()","code":""},{"path":"https://fspecque.github.io/test/reference/HarmonyIntegration.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Run Harmony on Seurat's Assay5 object through IntegrateLayers — HarmonyIntegration","text":"","code":"HarmonyIntegration(   object,   orig,   groups = NULL,   groups.name = NULL,   layers = NULL,   scale.layer = \"scale.data\",   features = NULL,   new.reduction = \"harmony\",   dims = NULL,   key = \"harmony_\",   seed.use = 42L,   theta = NULL,   sigma = 0.1,   lambda = NULL,   nclust = NULL,   ncores = 1L,   max_iter = 10,   early_stop = TRUE,   plot_convergence = FALSE,   .options = harmony_options(),   verbose = TRUE,   ... )  HarmonyIntegration.fix(...)"},{"path":"https://fspecque.github.io/test/reference/HarmonyIntegration.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Run Harmony on Seurat's Assay5 object through IntegrateLayers — HarmonyIntegration","text":"object Seurat object (Assay5 object called IntegrateLayers) orig DimReduc object. set directly called IntegrateLayers, use orig.reduction argument instead groups named data frame grouping information. Preferably one-column groups.name = NULL groups.name Column name groups data frame stores grouping information. groups.name = NULL, first column used layers Ignored unless groups = NULL, used create grouping variable correct batch-effect. scale.layer Ignored features Ignored new.reduction Name new integrated dimensional reduction dims Dimensions dimensional reduction use integration. used default key Prefix dimension names computed harmony. seed.use integer generate reproducible outputs. Set seed.use = NULL disable theta Diversity clustering penalty parameter. Specify variable vars_use Default theta=2. theta=0 encourage diversity. Larger values theta result diverse clusters. sigma Width soft kmeans clusters. Default sigma=0.1. Sigma scales distance cell cluster centroids. Larger values sigma result cells assigned clusters. Smaller values sigma make soft kmeans cluster approach hard clustering. lambda Ridge regression penalty. Default lambda=1. Bigger values protect correction. several covariates specified, lambda can also vector needs equal length number variables corrected. scenario, covariate level group assigned scalars specified user. set NULL, harmony start lambda estimation mode determine lambdas automatically try minimize overcorrection (Use caution still beta testing). nclust Number clusters model. nclust=1 equivalent simple linear regression. ncores Number processors used math operations optimized BLAS available. BLAS supporting multithreaded option effect. default, ncore=1 runs single-threaded process. Although Harmony supports multiple cores, optimized multithreading. Increase number large datasets iff single-core performance adequate. max_iter Maximum number rounds run Harmony. One round Harmony involves one clustering one correction step. early_stop Enable early stopping harmony. harmonization process stop change objective function corrections drops 1e-4 plot_convergence Whether print convergence plot clustering objective function. TRUE plot, FALSE suppress. can useful debugging. .options Setting advanced parameters RunHarmony. must result call `harmony_options`. See ?`harmony_options` parameters listed details. verbose Print messages. Set FALSE disable ... Ignored HarmonyIntegration(), HarmonyIntegration.fix()","code":""},{"path":"https://fspecque.github.io/test/reference/HarmonyIntegration.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Run Harmony on Seurat's Assay5 object through IntegrateLayers — HarmonyIntegration","text":"function returns list containing: new DimReduc name reduction.name (key set   reduction.key) corrected cell embeddings matrix   length(dims) columns. called via IntegrateLayers, Seurat object new reduction returned","code":""},{"path":"https://fspecque.github.io/test/reference/HarmonyIntegration.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Run Harmony on Seurat's Assay5 object through IntegrateLayers — HarmonyIntegration","text":"function requires harmony package installed","code":""},{"path":"https://fspecque.github.io/test/reference/HarmonyIntegration.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Run Harmony on Seurat's Assay5 object through IntegrateLayers — HarmonyIntegration","text":"Korsunsky, ., Millard, N., Fan, J., Slowikowski, K., Zhang, F., Wei, K., Baglaenko, Y., Brenner, M., Loh, P. & Raychaudhuri, S. Fast, sensitive accurate integration single-cell data Harmony. Nat Methods 16, 1289–1296 (2019). DOI","code":""},{"path":"https://fspecque.github.io/test/reference/HarmonyIntegration.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Run Harmony on Seurat's Assay5 object through IntegrateLayers — HarmonyIntegration","text":"","code":"if (FALSE) { # \\dontrun{ # Preprocessing obj <- UpdateSeuratObject(SeuratData::LoadData(\"pbmcsca\")) obj[[\"RNA\"]] <- split(obj[[\"RNA\"]], f = obj$Method) obj <- NormalizeData(obj) obj <- FindVariableFeatures(obj) obj <- ScaleData(obj) obj <- RunPCA(obj)  # After preprocessing, we integrate layers based on the \"Method\" variable: obj <- IntegrateLayers(object = obj, method = SeuratIntegrate::HarmonyIntegration,                        verbose = TRUE)  # We can also change parameters such as the batch-effect variable. # Here we change the groups variable, the number of dimension used from the original # PCA and minor options from `harmony_options()`: harmonyOptions <- harmony::harmony_options() harmonyOptions$max.iter.cluster <- 10   #  20 by default harmonyOptions$block.size <- .1         # .05 by default obj <- IntegrateLayers(object = obj, method = SeuratIntegrate::HarmonyIntegration,                        dims = 1:30, plot_convergence = TRUE,                        groups = obj[[]]$Experiment,                        new.reduction = \"harmony_custom\",                        .options = harmonyOptions, verbose = TRUE) } # }"},{"path":"https://fspecque.github.io/test/reference/MNNIntegration.html","id":null,"dir":"Reference","previous_headings":"","what":"Run classical MNN on Seurat's Assay5 object through IntegrateLayers — MNNIntegration","title":"Run classical MNN on Seurat's Assay5 object through IntegrateLayers — MNNIntegration","text":"wrapper run mnnCorrect multi-layered Seurat V5 object","code":""},{"path":"https://fspecque.github.io/test/reference/MNNIntegration.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Run classical MNN on Seurat's Assay5 object through IntegrateLayers — MNNIntegration","text":"","code":"MNNIntegration(   object,   orig = NULL,   groups = NULL,   layers = NULL,   scale.layer = NULL,   features = 2000,   reconstructed.assay = \"mnn.reconstructed\",   verbose = TRUE,   ... )"},{"path":"https://fspecque.github.io/test/reference/MNNIntegration.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Run classical MNN on Seurat's Assay5 object through IntegrateLayers — MNNIntegration","text":"object Seurat object (Assay5 object called IntegrateLayers) orig DimReduc object. set directly called IntegrateLayers, use orig.reduction argument instead groups Ignored layers Name layers use integration scale.layer Name scaled layer Assay features Either list features use calculating batch correction, number (2000 default) variable features select. reconstructed.assay Name assay containing low-rank reconstruction expression matrix. verbose Print messages. Set FALSE disable ... Extra parameters passed mnnCorrect","code":""},{"path":"https://fspecque.github.io/test/reference/MNNIntegration.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Run classical MNN on Seurat's Assay5 object through IntegrateLayers — MNNIntegration","text":"Seurat object merged objects object.list new DimReduc name reduction.name (key set reduction.key) corrected embeddings matrix well rotation matrix used PCA stored feature loadings slot. Also returns expression matrix reconstructed low-rank approximation reconstructed.assay assay; metadata info mnnCorrect stored tool slot, accessible Tool","code":""},{"path":"https://fspecque.github.io/test/reference/MNNIntegration.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Run classical MNN on Seurat's Assay5 object through IntegrateLayers — MNNIntegration","text":"function requires batchelor package installed","code":""},{"path":[]},{"path":"https://fspecque.github.io/test/reference/MNNIntegration.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Run classical MNN on Seurat's Assay5 object through IntegrateLayers — MNNIntegration","text":"","code":"if (FALSE) { # \\dontrun{ # Preprocessing obj <- UpdateSeuratObject(SeuratData::LoadData(\"pbmcsca\")) obj[[\"RNA\"]] <- split(obj[[\"RNA\"]], f = obj$Method) obj <- NormalizeData(obj) obj <- FindVariableFeatures(obj) obj <- ScaleData(obj) obj <- RunPCA(obj)  # After preprocessing, we integrate layers: obj <- IntegrateLayers(object = obj, method = MNNIntegration,   new.reduction = 'integrated.mnn', verbose = FALSE)  # We can also add parameters specific to mnnCorrect. # Here we set `k` to specify the number of nearest neighbors # to use when identifying MNNs: obj <- IntegrateLayers(object = obj, method = MNNIntegration,   new.reduction = 'integrated.mnn', k = 15, verbose = FALSE) } # }"},{"path":"https://fspecque.github.io/test/reference/NormaliseL2.html","id":null,"dir":"Reference","previous_headings":"","what":"Normalise a matrix using L2 norm — NormaliseL2","title":"Normalise a matrix using L2 norm — NormaliseL2","text":"Normalise rows columns matrix using L2 norm","code":""},{"path":"https://fspecque.github.io/test/reference/NormaliseL2.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Normalise a matrix using L2 norm — NormaliseL2","text":"","code":"NormaliseL2(mat, MARGIN = 1)"},{"path":"https://fspecque.github.io/test/reference/NormaliseL2.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Normalise a matrix using L2 norm — NormaliseL2","text":"mat matrix (sparse dense) MARGIN one 1 2, corresponding normalisation per rows columns respectively","code":""},{"path":"https://fspecque.github.io/test/reference/NormaliseL2.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Normalise a matrix using L2 norm — NormaliseL2","text":"matrix normalised rows columns","code":""},{"path":"https://fspecque.github.io/test/reference/NormaliseL2.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Normalise a matrix using L2 norm — NormaliseL2","text":"Adapted Seurat:::L2Norm","code":""},{"path":"https://fspecque.github.io/test/reference/PlotScores.html","id":null,"dir":"Reference","previous_headings":"","what":"Visualise and compare the performances of integration algorithms — PlotScores","title":"Visualise and compare the performances of integration algorithms — PlotScores","text":"Plot scaled integration scores compare obtained integrations","code":""},{"path":"https://fspecque.github.io/test/reference/PlotScores.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Visualise and compare the performances of integration algorithms — PlotScores","text":"","code":"PlotScores(   object,   plot.type = c(\"dot\", \"radar\", \"lollipop\"),   split.by.score.type = TRUE,   order.by = c(\"score\", \"name\", \"asis\"),   hide.zeros = FALSE,   include.integration = NULL,   exclude.integration = NULL,   include.score = NULL,   exclude.score = NULL,   recompute.overall.scores = TRUE,   rescale = TRUE,   batch.coeff = 0.4,   bio.coeff = 0.6,   point.max.size = 20L,   use.ggforce = is_installed(\"ggforce\") )"},{"path":"https://fspecque.github.io/test/reference/PlotScores.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Visualise and compare the performances of integration algorithms — PlotScores","text":"object Seurat object plot.type one 'table' (default), 'radar' 'lollipop'. Type desired plot split..score.type whether split scores type (bio-conservation, batch correction overall scores). set FALSE, scores mixed single figure. order.one 'score' (default), 'name' 'asis'. Determines order integrations legend (y-axis lolliplop table plots). Scores ordered decreasing overall score default, name row-order setting 'name' 'asis' respectively. hide.zeros whether zero(ed) scores visible plot. include.integration name integration(s) include. default value (NULL) enable include . exclude.integration name integration(s) exclude. default value (NULL) enable include . include.score name score(s) include. default value (NULL) enable include . exclude.score name score(s) exclude. default value (NULL) enable include . recompute.overall.scores whether recompute overall scores. Useful restriction scores plot. FALSE, coefficient parameters impact. rescale whether rescale score 0 1 using min-max normalisation computing overall scores. ensures metric equally contributes overall scores. effect recompute.overall.scores = FALSE. TRUE default batch.coeff weight batch correction performance evaluation scores overall score. bio.coeff weight bio-conservation performance evaluation scores overall score. point.max.size inoperative unless plot.type = 'table' use.ggforce = FALSE. Determine maximum size points (achieved score 1) fit plotting area (handled automaticaly ggforce used). use.ggforce plot.type = 'table', enable disable use ggforce draw circles. Used default package installed","code":""},{"path":"https://fspecque.github.io/test/reference/PlotScores.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Visualise and compare the performances of integration algorithms — PlotScores","text":"ggplot object","code":""},{"path":"https://fspecque.github.io/test/reference/ScaleScores.html","id":null,"dir":"Reference","previous_headings":"","what":"Scale the scores in the score tibble to plot them — ScaleScores","title":"Scale the scores in the score tibble to plot them — ScaleScores","text":"scores interest computed saved score tibble, can scaled make comparable bounding 0 1 harmonise direction (0 1 always mean bad good performance respectively). also prerequisite plotting.","code":""},{"path":"https://fspecque.github.io/test/reference/ScaleScores.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Scale the scores in the score tibble to plot them — ScaleScores","text":"","code":"ScaleScores(   object,   ref = \"Unintegrated\",   rescale = FALSE,   batch.coeff = 0.4,   bio.coeff = 0.6 )"},{"path":"https://fspecque.github.io/test/reference/ScaleScores.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Scale the scores in the score tibble to plot them — ScaleScores","text":"object Seurat object ref name integration use reference scaling. Useful PCA regression (density) cell cycle conservation scores. rescale whether rescale score 0 1 using min-max normalisation computing overall scores. ensures metric equally contributes overall scores. TRUE default batch.coeff weight batch correction performance evaluation scores overall score. bio.coeff weight bio-conservation performance evaluation scores overall score.","code":""},{"path":"https://fspecque.github.io/test/reference/ScanoramaIntegration.html","id":null,"dir":"Reference","previous_headings":"","what":"Run Scanorama on Seurat's Assay5 object through IntegrateLayers — ScanoramaIntegration","title":"Run Scanorama on Seurat's Assay5 object through IntegrateLayers — ScanoramaIntegration","text":"wrapper run Scanorama multi-layered Seurat V5 object. Requires conda environment scanorama necessary dependencies","code":""},{"path":"https://fspecque.github.io/test/reference/ScanoramaIntegration.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Run Scanorama on Seurat's Assay5 object through IntegrateLayers — ScanoramaIntegration","text":"","code":"ScanoramaIntegration(   object,   orig,   layers = NULL,   features = NULL,   scale.layer = \"scale.data\",   conda_env = NULL,   new.reduction = \"integrated.scanorama\",   reduction.key = \"scanorama_\",   reconstructed.assay = \"scanorama.reconstructed\",   ncores = 1L,   ndims.out = 100L,   return_dense = TRUE,   batch_size = 5000,   approx = TRUE,   sigma = 15L,   alpha = 0.1,   knn = 20L,   hvg.scanorama = NULL,   union.features = FALSE,   sketch = FALSE,   sketch_method = c(\"geosketch\", \"uniform\"),   sketch_max = 10000,   seed.use = 42L,   verbose = TRUE,   ... )"},{"path":"https://fspecque.github.io/test/reference/ScanoramaIntegration.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Run Scanorama on Seurat's Assay5 object through IntegrateLayers — ScanoramaIntegration","text":"object Seurat object (Assay5 object called IntegrateLayers) orig DimReduc object. set directly called IntegrateLayers, use orig.reduction argument instead layers Name layers use integration features Vector feature names input integration method. features = NULL (default), VariableFeatures used. pass features, use output Features() scale.layer Name scaled layer Assay conda_env Path conda environment run scanorama (also contain scipy python module). default, uses conda environment registered scanorama conda environment manager new.reduction Name store resulting dimensional reduction object. NULL FALSE disables dimension reduction computation reduction.key Key resulting dimensional reduction object. Ignored reduction.key NULL FALSE reconstructed.assay Name assay containing corrected expression matrix dimension #features x #cells. NULL FALSE disables corrected expression matrix computation ncores Number parallel threads create blas_set_num_threads. Pointless BLAS supporting multithreaded ndims.Number dimensions new.reduction output. Scanorama specific argument return_dense Whether scanorama returns numpy.ndarray matrices instead scipy.sparse.csr_matrix. Scanorama specific argument batch_size Used alignment vector computation. Higer values increase memory burden.Scanorama specific argument approx Whether scanorama approximates nearest neighbors computation. Scanorama specific argument sigma Correction smoothing parameter gaussian kernel. Scanorama specific argument alpha Minimum alignment score. Scanorama specific argument knn Number nearest neighbours used matching. Scanorama specific argument hvg.scanorama positive integer turn scanorama's internal HVG selection . Disabled default. Scanorama specific argument union.features default, scanorama uses intersection features perform integration. Set parameter TRUE use union. Discouraged. Scanorama specific argument sketch Turns sketching-based acceleration first downsampling datasets. See Hie et al., Cell Systems (2019). Disabled default. Ignored reconstructed.assay enabled. Scanorama specific argument sketch_method skething method apply data. Either 'geosketch' (default) 'uniform'. Ignored reconstructed.assay enabled sketch FALSE. Scanorama specific argument sketch_max Downsampling cutoff. Ignored sketching disabled. Scanorama specific argument seed.use integer generate reproducible outputs. Set seed.use = NULL disable verbose Print messages. Set FALSE disable ... Ignored","code":""},{"path":"https://fspecque.github.io/test/reference/ScanoramaIntegration.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Run Scanorama on Seurat's Assay5 object through IntegrateLayers — ScanoramaIntegration","text":"list containing least one : new DimReduc name reduction.name (key set   reduction.key) corrected embeddings matrix ndims.. new Assay name reconstructed.assay corrected counts   features (less hvg set lower integer). called via IntegrateLayers, Seurat object new reduction /assay returned","code":""},{"path":"https://fspecque.github.io/test/reference/ScanoramaIntegration.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Run Scanorama on Seurat's Assay5 object through IntegrateLayers — ScanoramaIntegration","text":"function requires Scanorama package installed (along scipy)","code":""},{"path":"https://fspecque.github.io/test/reference/ScanoramaIntegration.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Run Scanorama on Seurat's Assay5 object through IntegrateLayers — ScanoramaIntegration","text":"Hie, B., Bryson, B. & Berger, B. Efficient integration heterogeneous single-cell transcriptomes using Scanorama. Nat Biotechnol 37, 685–691 (2019). DOI","code":""},{"path":[]},{"path":"https://fspecque.github.io/test/reference/ScanoramaIntegration.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Run Scanorama on Seurat's Assay5 object through IntegrateLayers — ScanoramaIntegration","text":"","code":"if (FALSE) { # \\dontrun{ # Preprocessing obj <- SeuratData::LoadData(\"pbmcsca\") obj[[\"RNA\"]] <- split(obj[[\"RNA\"]], f = obj$Method) obj <- NormalizeData(obj) obj <- FindVariableFeatures(obj) obj <- ScaleData(obj) obj <- RunPCA(obj)  # After preprocessing, we integrate layers: obj <- IntegrateLayers(object = obj, method = ScanoramaIntegration)  # To disable feature expression matrix correction: obj <- IntegrateLayers(object = obj, method = ScanoramaIntegration,                        reconstructed.assay = NULL) } # }"},{"path":"https://fspecque.github.io/test/reference/SetMiscScore.html","id":null,"dir":"Reference","previous_headings":"","what":"Set the value of a score in the score tibble — SetMiscScore","title":"Set the value of a score in the score tibble — SetMiscScore","text":"Set score value given integration given score name. exist yet, created though AddMiscIntegrations AddMiscScores respectively.","code":""},{"path":"https://fspecque.github.io/test/reference/SetMiscScore.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Set the value of a score in the score tibble — SetMiscScore","text":"","code":"SetMiscScore(object, integration, score.name, score.value, ...)"},{"path":"https://fspecque.github.io/test/reference/SetMiscScore.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Set the value of a score in the score tibble — SetMiscScore","text":"object Seurat object integration name integration score computed. score.name name computed score score.value value score ... additional parameter pass AddMiscScores. effect score slot already present tibble. Otherwise, enable pass class argument specify class score slot create.","code":""},{"path":"https://fspecque.github.io/test/reference/SetMiscScore.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Set the value of a score in the score tibble — SetMiscScore","text":"Seurat object updated table scores.","code":""},{"path":"https://fspecque.github.io/test/reference/SeuratIntegrate-package.html","id":null,"dir":"Reference","previous_headings":"","what":"SeuratIntegrate: Expands the set of integration methods available to Seurat — SeuratIntegrate-package","title":"SeuratIntegrate: Expands the set of integration methods available to Seurat — SeuratIntegrate-package","text":"R package gathering set wrappers apply various integration methods Seurat objects (rate methods). Intended apply Seurat V5 objects bearing multiple layers.","code":""},{"path":[]},{"path":"https://fspecque.github.io/test/reference/SeuratIntegrate-package.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"SeuratIntegrate: Expands the set of integration methods available to Seurat — SeuratIntegrate-package","text":"Maintainer: Florian Specque florian.specque@u-bordeaux.fr (ORCID) Authors: Domitille Chalopin domitille.chalopin-fillot@u-bordeaux.fr (ORCID) contributors: Macha Nikolski macha.nikolski@u-bordeaux.fr (ORCID) [reviewer] Aurélien Barré aurelien.barre@u-bordeaux.fr (ORCID) [contributor] Centre de Bioinformatique de Bordeaux (CBiB) [copyright holder]","code":""},{"path":"https://fspecque.github.io/test/reference/SymmetrizeKnn.html","id":null,"dir":"Reference","previous_headings":"","what":"Symmetrize a nearest neighbours graph — SymmetrizeKnn","title":"Symmetrize a nearest neighbours graph — SymmetrizeKnn","text":"approximate nature nearest neighbour search algorithm used compute knn graph makes resulting adjacency matrix asymmetric. functions symmetrize Graph Neighbor object.","code":""},{"path":"https://fspecque.github.io/test/reference/SymmetrizeKnn.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Symmetrize a nearest neighbours graph — SymmetrizeKnn","text":"","code":"SymmetrizeKnn(object, graph.name = \"RNA_nn\", use.max = TRUE, assay = NULL)  # S4 method for class 'Seurat' SymmetrizeKnn(object, graph.name = \"RNA_nn\", use.max = TRUE, assay = NULL)  # S4 method for class 'Matrix' SymmetrizeKnn(object, use.max = TRUE)  # S4 method for class 'Graph' SymmetrizeKnn(object, use.max = TRUE)  # S4 method for class 'Neighbor' SymmetrizeKnn(object, use.max = TRUE)"},{"path":"https://fspecque.github.io/test/reference/SymmetrizeKnn.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Symmetrize a nearest neighbours graph — SymmetrizeKnn","text":"object Seurat, Graph Neighbor object graph.name name Graph Neighbor instance stored Seurat object. use.max default, use maximum value case discrepancy m[,j] m[j,]. Set FALSE use minimum value. assay name assay store output Graph","code":""},{"path":"https://fspecque.github.io/test/reference/SymmetrizeKnn.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Symmetrize a nearest neighbours graph — SymmetrizeKnn","text":"Seurat object new Graph instance dgCMatrix representing Graph ","code":""},{"path":[]},{"path":"https://fspecque.github.io/test/reference/UpdateEnvCache.html","id":null,"dir":"Reference","previous_headings":"","what":"Handy CondaEnvManger instance modifier — UpdateEnvCache","title":"Handy CondaEnvManger instance modifier — UpdateEnvCache","text":"Wrapper update CondaEnvManager object stored cache used configuration conda environments known methods (typically stored package's cache). single method can updated time. cases, best way modify package's conda environments registry.","code":""},{"path":"https://fspecque.github.io/test/reference/UpdateEnvCache.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Handy CondaEnvManger instance modifier — UpdateEnvCache","text":"","code":"UpdateEnvCache(   method = known.methods,   conda.bin = \"auto\",   conda.env = NULL,   conda.env.is.path = \"auto\",   separate.scvi.envs = FALSE,   overwrite.env = FALSE,   dry.run = FALSE )"},{"path":"https://fspecque.github.io/test/reference/UpdateEnvCache.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Handy CondaEnvManger instance modifier — UpdateEnvCache","text":"method name method update. One \"combat\", \"harmony\", \"mnn\", \"bbknn\", \"scvi\", \"scanvi\", \"scanorama\", \"trvae\" conda.bin path conda binary. empty (\"\"), NULL \"conda\", \"auto\" passed conda_binary() find path conda binary PATH conda.env Either name conda environment path environment. Must reachable provided conda.bin. NULL enable use default environment names. (see Details section) conda.env..path Whether conda.env path (TRUE), name (FALSE). default (\"auto\") guesses. careful make mistake switch non-default value separate.scvi.envs default, SCVI SCANVI share conda environment, since rely python package. wish distinct environment , set TRUE. Ignored method SCVI SCANVI. overwrite.env Turn TRUE enable overwriting existing environment (name path). provided conda.env already exists, default behaviour update package's registry existing environment dry.run TRUE, package's current cache updated. new conda environment () created. FALSE default.","code":""},{"path":"https://fspecque.github.io/test/reference/UpdateEnvCache.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Handy CondaEnvManger instance modifier — UpdateEnvCache","text":"CondaEnvManager object","code":""},{"path":"https://fspecque.github.io/test/reference/UpdateEnvCache.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Handy CondaEnvManger instance modifier — UpdateEnvCache","text":"conda environments default names : bbknn: SeuratIntegrate_scvi SCVI: SeuratIntegrate_scvi-tools SCANVI: SeuratIntegrate_scvi-tools scanorama: SeuratIntegrate_scanorama trVAE: SeuratIntegrate_trvae","code":""},{"path":[]},{"path":"https://fspecque.github.io/test/reference/add-score.html","id":null,"dir":"Reference","previous_headings":"","what":"Add integration(s) or score(s) slot(s) to the score tibble — add-score","title":"Add integration(s) or score(s) slot(s) to the score tibble — add-score","text":"AddMiscIntegrations: Add integration(s) slot(s) score tibble (make sure ). enables save scores later. AddMiscScores: Add score(s) slot(s) score tibble (make sure ). enables save later.","code":""},{"path":"https://fspecque.github.io/test/reference/add-score.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Add integration(s) or score(s) slot(s) to the score tibble — add-score","text":"","code":"AddMiscIntegrations(object, which)  AddMiscScores(object, which, class = \"numeric\")"},{"path":"https://fspecque.github.io/test/reference/add-score.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Add integration(s) or score(s) slot(s) to the score tibble — add-score","text":"object Seurat object name new integration(s) score(s) class class column, 'numeric' (default). instance, cell cycle conservation scores 'list' LISI scores 'numeric_lisi'.","code":""},{"path":"https://fspecque.github.io/test/reference/add-score.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Add integration(s) or score(s) slot(s) to the score tibble — add-score","text":"Seurat object updated table scores.","code":""},{"path":"https://fspecque.github.io/test/reference/bbknnIntegration.html","id":null,"dir":"Reference","previous_headings":"","what":"Run bbknn on Seurat's Assay5 object through IntegrateLayers — bbknnIntegration","title":"Run bbknn on Seurat's Assay5 object through IntegrateLayers — bbknnIntegration","text":"wrapper run bbknn multi-layered Seurat V5 object. Requires conda environment bbknn necessary dependencies","code":""},{"path":"https://fspecque.github.io/test/reference/bbknnIntegration.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Run bbknn on Seurat's Assay5 object through IntegrateLayers — bbknnIntegration","text":"","code":"bbknnIntegration(   object,   orig,   groups = NULL,   groups.name = NULL,   layers = \"data\",   scale.layer = \"scale.data\",   conda_env = NULL,   new.graph = \"bbknn\",   new.reduction = \"pca.bbknn\",   reduction.key = \"bbknnPCA_\",   reconstructed.assay = \"bbknn.ridge\",   ndims = 50L,   ndims.use = 30L,   ridge_regression = T,   graph.use = c(\"connectivities\", \"distances\"),   verbose = TRUE,   seed.use = 42L,   ... )"},{"path":"https://fspecque.github.io/test/reference/bbknnIntegration.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Run bbknn on Seurat's Assay5 object through IntegrateLayers — bbknnIntegration","text":"object Seurat object (Assay5 object called IntegrateLayers) orig DimReduc object. set directly called IntegrateLayers, use orig.reduction argument instead groups named data frame grouping information. Preferably one-column groups.name = NULL groups.name Column name groups data frame stores grouping information. groups.name = NULL, first column used layers Name layers use integration scale.layer Name scaled layer Assay conda_env Path conda environment run bbknn (also contain scipy python module).  default, uses conda environment registered bbknn conda environment manager new.graph Name Graph object new.reduction Name new integrated dimensional reduction reduction.key Key new integrated dimensional reduction reconstructed.assay Name assay containing corrected expression matrix ndims Number dimensions new PCA computed first output bbknn. 50 default. Ignored ridge_regression = FALSE ndims.use Number dimensions orig use bbknn, newly computed PCA ridge_regression = TRUE. ridge_regression set TRUE (default), new clusters computed output bbknn, ridge regression performed remove technical variables preserving biological variables. , new bbknn run performed. graph.use graph(s) bbknn output. least one \"connectivities\" \"distances\". provided (default) ridge_regression = TRUE, first one (\"connectivities\" default, recommended) used input computing clusters. verbose Print messages. Set FALSE disable seed.use integer generate reproducible outputs. Set seed.use = NULL disable ... Additional arguments passed bbknn.bbknn(). ridge_regression = TRUE, also accepts arguments pass Seurat::FindClusters(), Seurat::RunPCA() bbknn.ridge_regression(). See Details section","code":""},{"path":"https://fspecque.github.io/test/reference/bbknnIntegration.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Run bbknn on Seurat's Assay5 object through IntegrateLayers — bbknnIntegration","text":"list containing least one : 1 2 new Graph(s) name   [new_graph]_scale.data_[graph.use]   corresponding output(s) first run bbknn new Assay name reconstructed.assay corrected counts   feature scale.layer. new DimReduc (PCA) name new.reduction (key set   reduction.key) 1 2 new Graph(s) name   [new_graph]_ridge.residuals_[graph.use]   corresponding output(s) second run bbknn [graph.use] can take two values (either \"connectivities\" \"distances\"), depending graph.use parameter. called via IntegrateLayers, Seurat object new reduction /assay returned","code":""},{"path":"https://fspecque.github.io/test/reference/bbknnIntegration.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Run bbknn on Seurat's Assay5 object through IntegrateLayers — bbknnIntegration","text":"wrappers calls three python functions reticulate. Find bbknn-specific arguments : bbknn function:   bbknn.bbknn, relies   bbknn.matrix.bbknn ridge regression:   bbknn.ridge_regression, relies   sklearn.linear_model.Ridge","code":""},{"path":"https://fspecque.github.io/test/reference/bbknnIntegration.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Run bbknn on Seurat's Assay5 object through IntegrateLayers — bbknnIntegration","text":"function requires bbknn package installed (along scipy)","code":""},{"path":"https://fspecque.github.io/test/reference/bbknnIntegration.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Run bbknn on Seurat's Assay5 object through IntegrateLayers — bbknnIntegration","text":"Polański, K., Young, M. D., Miao, Z., Meyer, K. B., Teichmann, S. . & Park, J.-E. BBKNN: fast batch alignment single cell transcriptomes. Bioinformatics 36, 964–965 (2019). DOI","code":""},{"path":[]},{"path":"https://fspecque.github.io/test/reference/bbknnIntegration.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Run bbknn on Seurat's Assay5 object through IntegrateLayers — bbknnIntegration","text":"","code":"if (FALSE) { # \\dontrun{ # Preprocessing obj <- SeuratData::LoadData(\"pbmcsca\") obj[[\"RNA\"]] <- split(obj[[\"RNA\"]], f = obj$Method) obj <- NormalizeData(obj) obj <- FindVariableFeatures(obj) obj <- ScaleData(obj) obj <- RunPCA(obj)  # After preprocessing, we integrate layers: obj <- IntegrateLayers(object = obj, method = bbknnIntegration,                        conda_env = 'bbknn', groups = obj[[]],                        groups.name = 'Method')  # To disable the ridge regression and subsequent steps: obj <- IntegrateLayers(object = obj, method = bbknnIntegration,                        conda_env = 'bbknn', groups = obj[[]],                        groups.name = 'Method', ridge_regression = FALSE) } # }"},{"path":"https://fspecque.github.io/test/reference/checkCondaEnv.html","id":null,"dir":"Reference","previous_headings":"","what":"Check the validity of conda environment's components — checkCondaBin","title":"Check the validity of conda environment's components — checkCondaBin","text":"Check validity conda environment's components. Best used CondaEnv object. Internally call: checkCondaBin: conda_binary checkCondaEnvPath: condaenv_exists checkCondaEnvName: condaenv_exists checkCondaEnv: ","code":""},{"path":"https://fspecque.github.io/test/reference/checkCondaEnv.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Check the validity of conda environment's components — checkCondaBin","text":"","code":"checkCondaBin(x, ..., verbose = getOption(\"verbose\"))  checkCondaEnvPath(x, ..., verbose = getOption(\"verbose\"))  checkCondaEnvName(x, ..., verbose = getOption(\"verbose\"))  checkCondaEnv(x, ..., verbose = getOption(\"verbose\"))"},{"path":"https://fspecque.github.io/test/reference/checkCondaEnv.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Check the validity of conda environment's components — checkCondaBin","text":"x CondaEnv object sub element class CondaEnvSlot. checkCondaEnv() accepts CondaEnv object ... ignored x CondaEnv object. Otherwise, additional arguments reticulate functions Description conda = ... verbose ignored","code":""},{"path":"https://fspecque.github.io/test/reference/checkCondaEnv.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Check the validity of conda environment's components — checkCondaBin","text":"updated object class input x","code":""},{"path":"https://fspecque.github.io/test/reference/checkCondaEnv.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Check the validity of conda environment's components — checkCondaBin","text":"checkCondaEnv wrapper calls checks.","code":""},{"path":[]},{"path":"https://fspecque.github.io/test/reference/get-score.html","id":null,"dir":"Reference","previous_headings":"","what":"Retrieve integration scores from a Seurat object — GetMiscIntegrations","title":"Retrieve integration scores from a Seurat object — GetMiscIntegrations","text":"Scores stored tibble objects Misc. Slot raw scores named 'si_scores' scaled scores found 'si_scaled.scores'. GetMiscIntegrations: Get (search ) integration names score tibble GetMiscScores:  Get (search ) score names score tibble IntegrationScores: Get tibble scaled unscaled scores","code":""},{"path":"https://fspecque.github.io/test/reference/get-score.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Retrieve integration scores from a Seurat object — GetMiscIntegrations","text":"","code":"GetMiscIntegrations(object, search = NULL)  GetMiscScores(object, search = NULL)  IntegrationScores(object, scaled = FALSE)"},{"path":"https://fspecque.github.io/test/reference/get-score.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Retrieve integration scores from a Seurat object — GetMiscIntegrations","text":"object Seurat object search character vector names search case-insensitive exact match. NULL disables search (default) scaled whether query unscaled (default) scaled scores (scaling performed)","code":""},{"path":"https://fspecque.github.io/test/reference/get-score.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Retrieve integration scores from a Seurat object — GetMiscIntegrations","text":"GetMiscIntegrations: character vector integration names, NULL object 'si_scores' Misc search return result. GetMiscScores: character vector score names, NULL object 'si_scores' Misc search return result. IntegrationScores: either NULL requested object exist, otherwise tibble. first column contains name integrations, following column corresponds score.","code":""},{"path":"https://fspecque.github.io/test/reference/getCache.html","id":null,"dir":"Reference","previous_headings":"","what":"Get current cache of conda environments — getCache","title":"Get current cache of conda environments — getCache","text":"Get current cache conda environments package environment cache disk","code":""},{"path":"https://fspecque.github.io/test/reference/getCache.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Get current cache of conda environments — getCache","text":"","code":"getCache(from = c(\"env\", \"cache\"))"},{"path":"https://fspecque.github.io/test/reference/getCache.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Get current cache of conda environments — getCache","text":"Either \"env\" \"cache\". load cache .","code":""},{"path":"https://fspecque.github.io/test/reference/getCache.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Get current cache of conda environments — getCache","text":"CondaEnvManager object","code":""},{"path":"https://fspecque.github.io/test/reference/getCachePath.html","id":null,"dir":"Reference","previous_headings":"","what":"Get path to package config cache — getCachePath","title":"Get path to package config cache — getCachePath","text":"Get path package config cache file directory","code":""},{"path":"https://fspecque.github.io/test/reference/getCachePath.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Get path to package config cache — getCachePath","text":"","code":"getCachePath(include.file = TRUE)"},{"path":"https://fspecque.github.io/test/reference/getCachePath.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Get path to package config cache — getCachePath","text":"include.file Set FALSE retrieve directory containing cache file. Return path file default.","code":""},{"path":"https://fspecque.github.io/test/reference/getCachePath.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Get path to package config cache — getCachePath","text":"single character, path cache file directory","code":""},{"path":"https://fspecque.github.io/test/reference/isValid.html","id":null,"dir":"Reference","previous_headings":"","what":"Check the validity of conda environment's components — isValid","title":"Check the validity of conda environment's components — isValid","text":"Get validity conda environment's components. Best used CondaEnvManager CondaEnv object.","code":""},{"path":"https://fspecque.github.io/test/reference/isValid.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Check the validity of conda environment's components — isValid","text":"","code":"isValid(x, ...)  # S4 method for class 'CondaEnvSlot' isValid(x, ...)  # S4 method for class 'CondaEnv' isValid(x, do.check = FALSE, ...)  # S4 method for class 'CondaEnvManager' isValid(x, ...)"},{"path":"https://fspecque.github.io/test/reference/isValid.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Check the validity of conda environment's components — isValid","text":"x CondaEnvManager, CondaEnv object sub element class CondaEnvSlot. ... ignored x CondaEnvSlot object. Otherwise, can used pass .check argument. .check whether call check functions. apply x CondaEnvSlot object.","code":""},{"path":"https://fspecque.github.io/test/reference/isValid.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Check the validity of conda environment's components — isValid","text":"TRUE FALSE logical named vector x CondaEnvManager object (one element per method)","code":""},{"path":[]},{"path":"https://fspecque.github.io/test/reference/matrix-indexing.html","id":null,"dir":"Reference","previous_headings":"","what":"Matrix indexing — matrix-indexing","title":"Matrix indexing — matrix-indexing","text":"Switch rows & columns indices vector-like indices matrices.rowcol2idx get indices rows columnsidx2col get columns indicesidx2row get rows indices","code":""},{"path":"https://fspecque.github.io/test/reference/matrix-indexing.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Matrix indexing — matrix-indexing","text":"","code":"rowcol2idx(rows.idx, cols.idx, height)  idx2col(idx, height)  idx2row(idx, height)"},{"path":"https://fspecque.github.io/test/reference/matrix-indexing.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Matrix indexing — matrix-indexing","text":"rows.idx indices rows cols.idx indices columns height height matrix (number rows) idx vector-like, matrix-wide indices","code":""},{"path":"https://fspecque.github.io/test/reference/matrix-indexing.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Matrix indexing — matrix-indexing","text":"vector indices","code":""},{"path":"https://fspecque.github.io/test/reference/matrix-sorting.html","id":null,"dir":"Reference","previous_headings":"","what":"Matrix sorting — matrix-sorting","title":"Matrix sorting — matrix-sorting","text":"Sort matrix row- column-wise manner, check isrowSort sort row independentlycolSort sort column independentlyrowSorted check row independently sortedcolSorted check column independently sorted","code":""},{"path":"https://fspecque.github.io/test/reference/matrix-sorting.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Matrix sorting — matrix-sorting","text":"","code":"rowSort(mat, by = NULL, ncol = NULL, decreasing = FALSE)  colSort(mat, by = NULL, ncol = NULL, decreasing = FALSE)  rowSorted(mat, decreasing = FALSE)  colSorted(mat, decreasing = FALSE)"},{"path":"https://fspecque.github.io/test/reference/matrix-sorting.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Matrix sorting — matrix-sorting","text":"mat matrix sort check matrix sort . NULL, sort mat (default) ncol number desired columns sorted mat. NULL, keep original dimensions mat (default) decreasing logical.  sort increasing decreasing?     available partial sorting.","code":""},{"path":"https://fspecque.github.io/test/reference/matrix-sorting.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Matrix sorting — matrix-sorting","text":"sorted matrix ncol columns","code":""},{"path":"https://fspecque.github.io/test/reference/matrix-sorting.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Matrix sorting — matrix-sorting","text":"mat different dimensions, results might incorrect","code":""},{"path":"https://fspecque.github.io/test/reference/matrix-symmetrize.html","id":null,"dir":"Reference","previous_headings":"","what":"Matrix symmetrizing — matrix-symmetrize","title":"Matrix symmetrizing — matrix-symmetrize","text":"Create sparse matrix using , j x (row indices, column indicies values respectively) symmetrizes low memory footprintsymmetrize.pmax.sparse symmetrize matrix max(m[,j], m[j,])symmetrize.pmin.sparse symmetrize matrix min(m[,j], m[j,])","code":""},{"path":"https://fspecque.github.io/test/reference/matrix-symmetrize.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Matrix symmetrizing — matrix-symmetrize","text":"","code":"symmetrize.pmax.sparse(i, j, x, height)  symmetrize.pmin.sparse(i, j, x, height)"},{"path":"https://fspecque.github.io/test/reference/matrix-symmetrize.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Matrix symmetrizing — matrix-symmetrize","text":"row indices (1-based) j column indices (1-based) x values m[,j] = x height height matrix (number rows)","code":""},{"path":"https://fspecque.github.io/test/reference/matrix-symmetrize.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Matrix symmetrizing — matrix-symmetrize","text":"symmetric sparse dgCMatrix size height x height","code":""},{"path":[]},{"path":"https://fspecque.github.io/test/reference/numeric_lisi-methods.html","id":null,"dir":"Reference","previous_headings":"","what":"Convert a numeric vector to a `numeric_lisi` vector — as.numeric,numeric_lisi-method","title":"Convert a numeric vector to a `numeric_lisi` vector — as.numeric,numeric_lisi-method","text":"Convert numeric vector `numeric_lisi` vector Indexing method `numeric_lisi` (keep `@N` slot) Replicate method numeric_lisi (keep `@N` slot) Value replacement method `numeric_lisi` (check `@N` slot compatibility)","code":""},{"path":"https://fspecque.github.io/test/reference/numeric_lisi-methods.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Convert a numeric vector to a `numeric_lisi` vector — as.numeric,numeric_lisi-method","text":"","code":"# S4 method for class 'numeric_lisi' as.numeric(x)  # S4 method for class 'numeric_lisi,ANY,ANY,ANY' x[i]  # S4 method for class 'numeric_lisi' rep(x, ...)  # S4 method for class 'numeric_lisi,ANY,ANY,ANY' x[i] <- value"},{"path":"https://fspecque.github.io/test/reference/numeric_lisi-methods.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Convert a numeric vector to a `numeric_lisi` vector — as.numeric,numeric_lisi-method","text":"x numeric_lisi vector indices specifying elements extract replace ... passed rep.numeric value value replace ","code":""},{"path":"https://fspecque.github.io/test/reference/reloadCache.html","id":null,"dir":"Reference","previous_headings":"","what":"Reload cache from disk — reloadCache","title":"Reload cache from disk — reloadCache","text":"Reload cache disk update current list conda environments package environment","code":""},{"path":"https://fspecque.github.io/test/reference/reloadCache.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Reload cache from disk — reloadCache","text":"","code":"reloadCache()"},{"path":"https://fspecque.github.io/test/reference/reloadCache.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Reload cache from disk — reloadCache","text":"CondaEnvManager object (invisibly)","code":""},{"path":"https://fspecque.github.io/test/reference/resetCache.html","id":null,"dir":"Reference","previous_headings":"","what":"Reset a conda environment — resetCache","title":"Reset a conda environment — resetCache","text":"Reset (unset) conda environment linked provided method. Update cache disk package environment","code":""},{"path":"https://fspecque.github.io/test/reference/resetCache.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Reset a conda environment — resetCache","text":"","code":"resetCache(method = known.methods)"},{"path":"https://fspecque.github.io/test/reference/resetCache.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Reset a conda environment — resetCache","text":"method name method update. One \"combat\", \"harmony\", \"mnn\", \"bbknn\", \"scvi\", \"scanvi\", \"scanorama\", \"trvae\"","code":""},{"path":"https://fspecque.github.io/test/reference/resetCache.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Reset a conda environment — resetCache","text":"CondaEnvManager object (invisibly)","code":""},{"path":"https://fspecque.github.io/test/reference/saveToCache.html","id":null,"dir":"Reference","previous_headings":"","what":"Save a conda environment manager to cache — saveToCache","title":"Save a conda environment manager to cache — saveToCache","text":"Save conda environment manager cache ( R_user_dir(\"SeuratIntegrate\", = \"config\")) data.frame compressed RDS file.","code":""},{"path":"https://fspecque.github.io/test/reference/saveToCache.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Save a conda environment manager to cache — saveToCache","text":"","code":"saveToCache(x, ..., verbose = getOption(\"verbose\"))  # S4 method for class 'CondaEnvManager' saveToCache(x)"},{"path":"https://fspecque.github.io/test/reference/saveToCache.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Save a conda environment manager to cache — saveToCache","text":"x CondaEnvManager object ... ignored verbose ignored","code":""},{"path":[]},{"path":"https://fspecque.github.io/test/reference/scANVIIntegration.html","id":null,"dir":"Reference","previous_headings":"","what":"Run scANVI on Seurat's Assay5 object through IntegrateLayers — scANVIIntegration","title":"Run scANVI on Seurat's Assay5 object through IntegrateLayers — scANVIIntegration","text":"wrapper run scANVI multi-layered Seurat V5 object. Requires conda environment scvi-tools necessary dependencies Recommendations: use raw counts features (features = Features(object), layers = \"counts\")","code":""},{"path":"https://fspecque.github.io/test/reference/scANVIIntegration.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Run scANVI on Seurat's Assay5 object through IntegrateLayers — scANVIIntegration","text":"","code":"scANVIIntegration(   object,   groups = NULL,   groups.name = NULL,   labels.name = NULL,   labels.null = NULL,   features = NULL,   layers = \"counts\",   scale.layer = \"scale.data\",   conda_env = NULL,   new.reduction = \"integrated.scANVI\",   reduction.key = \"scANVIlatent_\",   torch.intraop.threads = 4L,   torch.interop.threads = NULL,   model.save.dir = NULL,   ndims.out = 10,   n_hidden = 128L,   n_layers = 1L,   dropout_rate = 0.1,   dispersion = c(\"gene\", \"gene-batch\", \"gene-label\", \"gene-cell\"),   gene_likelihood = c(\"zinb\", \"nb\", \"poisson\"),   linear_classifier = FALSE,   max_epochs = NULL,   train_size = 0.9,   batch_size = 128L,   seed.use = 42L,   verbose = TRUE,   verbose.scvi = c(\"INFO\", \"NOTSET\", \"DEBUG\", \"WARNING\", \"ERROR\", \"CRITICAL\"),   ... )"},{"path":"https://fspecque.github.io/test/reference/scANVIIntegration.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Run scANVI on Seurat's Assay5 object through IntegrateLayers — scANVIIntegration","text":"object Seurat object (Assay5 object called IntegrateLayers) groups named data frame grouping information. Can also contain cell labels guide scANVI. groups.name Column name groups data frame stores grouping information. groups.name = NULL, first column used labels.name Column name groups data frame stores cell label information. labels.name = NULL, cells assigned label. labels.null One value groups$labels.name indicates unlabeled observations. labels.null = NULL means labels valid. applies labels.name != NULL. features Vector feature names input integration method. features = NULL (default), VariableFeatures used. pass features, use output Features() layers Name layers use integration. 'counts' highly recommended scale.layer Name scaled layer Assay conda_env Path conda environment run scANVI (also contain scipy python module).  default, uses conda environment registered scANVI conda environment manager new.reduction Name new integrated dimensional reduction reduction.key Key new integrated dimensional reduction torch.intraop.threads Number intra-op threads available torch training CPU instead GPU. Set via torch.set_num_threads(). torch.interop.threads Number intra-op threads available torch training CPU instead GPU. Set via torch.set_num_interop_threads(). Can changed , first call. model.save.dir Path directory save model . Uses SCANVI.save(). save anndata. Note neither trainer optimizer state trainer history saved. model.save.dir = NULL (default) disables saving model. ndims.Number dimensions new.reduction output. Corresponds n_latent argument original API SCANVI n_hidden Number nodes per hidden layer. n_layers Number hidden layers used encoder decoder NNs. dropout_rate Dropout rate neural networks. dispersion One following: gene: dispersion parameter NB constant per gene across cells (default) gene-batch: dispersion can differ different batches gene-label: dispersion can differ different labels gene-cell: dispersion can differ every gene every cell gene_likelihood One following: zinb: Zero-inflated negative binomial distribution (default) nb: Negative binomial distribution poisson: Poisson distribution linear_classifier switched TRUE, uses single linear layer classification instead multi-layer perceptron. max_epochs Number passes dataset semisupervised training. train_size Size training set range [0.0, 1.0] batch_size Minibatch size use training. seed.use integer generate reproducible outputs. Set seed.use = NULL disable verbose Print messages. Set FALSE disable verbose.scvi Verbosity level scANVI. quietest talkiest: CRITICAL, ERROR, WARNING, INFO (default), DEBUG, NOTSET ... Additional arguments passed scvi.model.SCANVI, SCANVI.setup_anndata SCANVI.train (see Details section)","code":""},{"path":"https://fspecque.github.io/test/reference/scANVIIntegration.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Run scANVI on Seurat's Assay5 object through IntegrateLayers — scANVIIntegration","text":"list containing: new DimReduc name new.reduction (key set   reduction.key) consisting latent space model   ndims.dimensions. called via IntegrateLayers, Seurat object new reduction /assay returned","code":""},{"path":"https://fspecque.github.io/test/reference/scANVIIntegration.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Run scANVI on Seurat's Assay5 object through IntegrateLayers — scANVIIntegration","text":"wrappers calls three python functions reticulate. Find scVANVI-specific arguments : model initiation:   scvi.model.SCANVI, relies   scvi.module.SCANVAE turn relies   scvi.module.VAE anndata setup:   SCANVI.setup_anndata training:   SCANVI.train","code":""},{"path":"https://fspecque.github.io/test/reference/scANVIIntegration.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Run scANVI on Seurat's Assay5 object through IntegrateLayers — scANVIIntegration","text":"function requires scvi-tools package installed (along scipy)","code":""},{"path":"https://fspecque.github.io/test/reference/scANVIIntegration.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Run scANVI on Seurat's Assay5 object through IntegrateLayers — scANVIIntegration","text":"Kingma, D. P., Rezende, D. J., Mohamed, S. & Welling, M. Semi- Supervised Learning Deep Generative Models. Preprint arXiv (2014). DOI Xu, C., Lopez, R., Mehlman, E., Regier, J., Jordan, M. . & Yosef, N. Probabilistic harmonization annotation single‐cell transcriptomics data deep generative models. Molecular Systems Biology 17, (2021). DOI","code":""},{"path":[]},{"path":"https://fspecque.github.io/test/reference/scANVIIntegration.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Run scANVI on Seurat's Assay5 object through IntegrateLayers — scANVIIntegration","text":"","code":"if (FALSE) { # \\dontrun{ # Preprocessing obj <- SeuratData::LoadData(\"pbmcsca\") obj[[\"RNA\"]] <- split(obj[[\"RNA\"]], f = obj$Method) obj <- NormalizeData(obj) obj <- FindVariableFeatures(obj) obj <- ScaleData(obj) obj <- RunPCA(obj)  # After preprocessing, we integrate layers: obj <- IntegrateLayers(object = obj, method = scANVIIntegration,                        features = Features(obj), conda_env = 'scvi-tools',                        layers = 'counts', groups = obj[[]], groups.name = 'Method',                        labels.name = 'CellType', labels.null = 'Unassigned')  # To enable saving the model, add other 'nuisance' factors and increase number of threads used: obj <- IntegrateLayers(object = obj, method = scANVIIntegration,                        features = Features(obj), conda_env = 'scvi-tools',                        layers = 'counts', groups = obj[[]], groups.name = \"Method\",                        labels.name = \"CellType\", labels.null = \"Unassigned\",                        categorical_covariate_keys = \"Experiment\",                        continuous_covariate_keys = \"percent.mito\",                        ncores = 8, model.save.dir = '~/Documents/scANVI.model') } # }"},{"path":"https://fspecque.github.io/test/reference/scVIIntegration.html","id":null,"dir":"Reference","previous_headings":"","what":"Run scVI on Seurat's Assay5 object through IntegrateLayers — scVIIntegration","title":"Run scVI on Seurat's Assay5 object through IntegrateLayers — scVIIntegration","text":"wrapper run scVI multi-layered Seurat V5 object. Requires conda environment scvi-tools necessary dependencies Can called via SeuratIntegrate::scVIIntegration() scVIIntegration.fix() Recommendations: use raw counts features (features = Features(object), layers = \"counts\")","code":""},{"path":"https://fspecque.github.io/test/reference/scVIIntegration.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Run scVI on Seurat's Assay5 object through IntegrateLayers — scVIIntegration","text":"","code":"scVIIntegration(   object,   groups = NULL,   groups.name = NULL,   labels.name = NULL,   features = NULL,   layers = \"counts\",   scale.layer = \"scale.data\",   conda_env = NULL,   new.reduction = \"integrated.scVI\",   reduction.key = \"scVIlatent_\",   torch.intraop.threads = 4L,   torch.interop.threads = NULL,   model.save.dir = NULL,   ndims.out = 10,   n_hidden = 128L,   n_layers = 1L,   dropout_rate = 0.1,   dispersion = c(\"gene\", \"gene-batch\", \"gene-label\", \"gene-cell\"),   gene_likelihood = c(\"zinb\", \"nb\", \"poisson\"),   latent_distribution = c(\"normal\", \"ln\"),   max_epochs = NULL,   train_size = 0.9,   batch_size = 128L,   seed.use = 42L,   verbose = TRUE,   verbose.scvi = c(\"INFO\", \"NOTSET\", \"DEBUG\", \"WARNING\", \"ERROR\", \"CRITICAL\"),   ... )  scVIIntegration.fix(...)"},{"path":"https://fspecque.github.io/test/reference/scVIIntegration.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Run scVI on Seurat's Assay5 object through IntegrateLayers — scVIIntegration","text":"object Seurat object (Assay5 object called IntegrateLayers) groups named data frame grouping information. groups.name Column name groups data frame stores grouping information. groups.name = NULL, first column used labels.name Column name groups data frame stores cell label information. labels.name = NULL, cells assigned label. features Vector feature names input integration method. features = NULL (default), VariableFeatures used. pass features, use output Features() layers Name layers use integration. 'counts' highly recommended scale.layer Name scaled layer Assay conda_env Path conda environment run scVI (also contain scipy python module).  default, uses conda environment registered scVI conda environment manager new.reduction Name new integrated dimensional reduction reduction.key Key new integrated dimensional reduction torch.intraop.threads Number intra-op threads available torch training CPU instead GPU. Set via torch.set_num_threads(). torch.interop.threads Number intra-op threads available torch training CPU instead GPU. Set via torch.set_num_interop_threads(). Can changed , first call. model.save.dir Path directory save model . Uses SCVI.save(). save anndata. Note neither trainer optimizer state trainer history saved. model.save.dir = NULL (default) disables saving model. ndims.Number dimensions new.reduction output. Corresponds n_latent argument original API SCVI n_hidden Number nodes per hidden layer. n_layers Number hidden layers used encoder decoder NNs. dropout_rate Dropout rate neural networks. dispersion One following: gene: dispersion parameter NB constant per gene across cells (default) gene-batch: dispersion can differ different batches gene-label: dispersion can differ different labels gene-cell: dispersion can differ every gene every cell gene_likelihood One following: zinb: Zero-inflated negative binomial distribution (default) nb: Negative binomial distribution poisson: Poisson distribution latent_distribution One following: normal: Normal distribution (default) ln: Logistic normal distribution (Normal(0, ) transformed softmax) max_epochs Number passes dataset semisupervised training. train_size Size training set range [0.0, 1.0] batch_size Minibatch size use training. seed.use integer generate reproducible outputs. Set seed.use = NULL disable verbose Print messages. Set FALSE disable verbose.scvi Verbosity level scVI. quietest talkiest: CRITICAL, ERROR, WARNING, INFO (default), DEBUG, NOTSET ... scVIIntegration(), additional arguments passed scvi.model.SCVI, SCVI.setup_anndata SCVI.train (see Details section). scVIIntegration.fix(), ","code":""},{"path":"https://fspecque.github.io/test/reference/scVIIntegration.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Run scVI on Seurat's Assay5 object through IntegrateLayers — scVIIntegration","text":"list containing: new DimReduc name new.reduction (key set   reduction.key) consisting latent space model   ndims.dimensions. called via IntegrateLayers, Seurat object new reduction /assay returned","code":""},{"path":"https://fspecque.github.io/test/reference/scVIIntegration.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Run scVI on Seurat's Assay5 object through IntegrateLayers — scVIIntegration","text":"wrappers calls three python functions reticulate. Find scVI-specific arguments : model initiation:   scvi.model.SCVI, relies   scvi.module.VAE anndata setup:   SCVI.setup_anndata training:   SCVI.train","code":""},{"path":"https://fspecque.github.io/test/reference/scVIIntegration.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Run scVI on Seurat's Assay5 object through IntegrateLayers — scVIIntegration","text":"function requires scvi-tools package installed (along scipy)","code":""},{"path":"https://fspecque.github.io/test/reference/scVIIntegration.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Run scVI on Seurat's Assay5 object through IntegrateLayers — scVIIntegration","text":"Lopez, R., Regier, J., Cole, M. B., Jordan, M. . & Yosef, N. Deep generative modeling single-cell transcriptomics. Nat Methods 15, 1053–1058 (2018). DOI","code":""},{"path":[]},{"path":"https://fspecque.github.io/test/reference/scVIIntegration.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Run scVI on Seurat's Assay5 object through IntegrateLayers — scVIIntegration","text":"","code":"if (FALSE) { # \\dontrun{ # Preprocessing obj <- SeuratData::LoadData(\"pbmcsca\") obj[[\"RNA\"]] <- split(obj[[\"RNA\"]], f = obj$Method) obj <- NormalizeData(obj) obj <- FindVariableFeatures(obj) obj <- ScaleData(obj) obj <- RunPCA(obj)  # After preprocessing, we integrate layers: obj <- IntegrateLayers(object = obj, method = scVIIntegration,                        features = Features(obj), conda_env = 'scvi-tools',                        layers = 'counts', groups = obj[[]], groups.name = 'Method')  # To enable cell label-guided correction, save the model, add other # 'nuisance' factors and increase number of threads used: obj <- IntegrateLayers(object = obj, method = scVIIntegration,                        features = Features(obj), conda_env = 'scvi-tools',                        layers = 'counts', groups = obj[[]], groups.name = \"Method\",                        labels.name = \"CellType\",                        categorical_covariate_keys = list(\"Experiment\"),                        continuous_covariate_keys = list(\"percent.mito\"),                        ncores = 8, model.save.dir = '~/Documents/scVI.model') } # }"},{"path":"https://fspecque.github.io/test/reference/score-ari.html","id":null,"dir":"Reference","previous_headings":"","what":"Score a clustering result with adjusted rand index — ScoreARI","title":"Score a clustering result with adjusted rand index — ScoreARI","text":"Compute score based adjusted rand index clustering result one cell type label variable(s). 0 1 reflect random clustering perfect clustering compared cell type labelling respectively.","code":""},{"path":"https://fspecque.github.io/test/reference/score-ari.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Score a clustering result with adjusted rand index — ScoreARI","text":"","code":"ScoreARI(object, cell.var, clust.var = \"seurat_clusters\")  AddScoreARI(object, integration, cell.var, clust.var = \"seurat_clusters\")"},{"path":"https://fspecque.github.io/test/reference/score-ari.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Score a clustering result with adjusted rand index — ScoreARI","text":"object Seurat object cell.var name(s) column(s) cell type label variable (must object metadata). Multiple column names accepted clust.var name column cluster id assignment cell (must object metadata). one column name accepted integration name integration score","code":""},{"path":"https://fspecque.github.io/test/reference/score-ari.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Score a clustering result with adjusted rand index — ScoreARI","text":"ScoreARI: named array many values common strings cell.var column names object's metadata. Names cell.var values ARI. AddScoreARI: updated Seurat object ARI score(s) set integration.","code":""},{"path":"https://fspecque.github.io/test/reference/score-ari.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Score a clustering result with adjusted rand index — ScoreARI","text":"ARI rand index corrected chance: $$\\displaystyle ARI = \\frac{RI - RI_{expected}}{max(RI) - RI_{expected}}$$ precisely, contingency table computed two variables \\(L\\) \\(C\\) \\(r\\) \\(s\\) elements respectively. \\(\\[\\![1,r]\\!]\\) \\(j \\[\\![1,s]\\!]\\), \\(n_{ij}\\) number common samples (.e. cells) \\(L_i\\) \\(C_j\\), \\(a_i\\) number samples \\(L_i\\) \\(b_j\\) number samples \\(C_j\\). ARI : $$\\displaystyle ARI = \\frac{\\left. \\sum_{ij} \\binom{n_{ij}}{2} - \\left(\\sum_i \\binom{a_i}{2} \\sum_j \\binom{b_j}{2}\\right) \\right/ \\binom{n}{2} }{ \\left. \\frac{1}{2} \\left(\\sum_i \\binom{a_i}{2} + \\sum_j \\binom{b_j}{2}\\right) - \\left(\\sum_i \\binom{a_i}{2} \\sum_j \\binom{b_j}{2}\\right) \\right/ \\binom{n}{2}}$$","code":""},{"path":"https://fspecque.github.io/test/reference/score-ari.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Score a clustering result with adjusted rand index — ScoreARI","text":"metric symmetric. Switching cell.var clust.var return value.","code":""},{"path":"https://fspecque.github.io/test/reference/score-ari.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Score a clustering result with adjusted rand index — ScoreARI","text":"Luecken, M. D., Büttner, M., Chaichoompu, K., Danese, ., Interlandi, M., Mueller, M. F., Strobl, D. C., Zappia, L., Dugas, M., Colomé-Tatché, M. & Theis, F. J. Benchmarking atlas-level data integration single-cell genomics. Nat Methods 19, 41–50 (2021). DOI","code":""},{"path":"https://fspecque.github.io/test/reference/score-asw.html","id":null,"dir":"Reference","previous_headings":"","what":"Score an embedding or a count matrix with the average silhouette width — score-asw","title":"Score an embedding or a count matrix with the average silhouette width — score-asw","text":"Compute scores based average silhouette width (ASW) metric. ScoreASW: First, cell--cell distances computed provided embedding layer matrix. , silhouette score calculated estimate quality partition according variable cell type labels. Hence, score measures extent cells identical label cluster together. ScoreASWBatch: Similar, batch variable. score provides estimation batch mixing.","code":""},{"path":"https://fspecque.github.io/test/reference/score-asw.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Score an embedding or a count matrix with the average silhouette width — score-asw","text":"","code":"ScoreASW(   object,   cell.var,   what,   assay = NULL,   metric = c(\"euclidean\", \"cosine\", \"angular\", \"manhattan\", \"hamming\"),   dist.package = c(\"distances\", \"Rfast\", \"parallelDist\", \"stats\"),   verbose = TRUE,   ... )  AddScoreASW(   object,   integration,   cell.var,   what,   assay = NULL,   metric = c(\"euclidean\", \"cosine\", \"angular\", \"manhattan\", \"hamming\"),   dist.package = c(\"distances\", \"Rfast\", \"parallelDist\", \"stats\"),   verbose = TRUE,   ... )  ScoreASWBatch(   object,   batch.var = NULL,   cell.var = NULL,   what,   per.cell.var = TRUE,   assay = NULL,   metric = c(\"euclidean\", \"cosine\", \"angular\", \"manhattan\", \"hamming\"),   dist.package = c(\"distances\", \"Rfast\", \"parallelDist\", \"stats\"),   verbose = TRUE,   ... )  AddScoreASWBatch(   object,   integration,   batch.var = NULL,   cell.var = NULL,   what,   per.cell.var = TRUE,   assay = NULL,   metric = c(\"euclidean\", \"cosine\", \"angular\", \"manhattan\", \"hamming\"),   dist.package = c(\"distances\", \"Rfast\", \"parallelDist\", \"stats\"),   verbose = TRUE,   ... )"},{"path":"https://fspecque.github.io/test/reference/score-asw.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Score an embedding or a count matrix with the average silhouette width — score-asw","text":"object Seurat object cell.var name column cell type label variable (must object metadata). Ignored ScoreASWBatch per.cell.var = FALSE name dimension reduction layer score. Must Seurat object obtainable JoinLayers() call. assay name assay use. output DefaultAssay() used default metric name distance metric use. One 'euclidean', 'cosine', 'angular', 'manhattan', 'hamming'. See Note details. dist.package name package compute distances . One 'distances', 'Rfast' ,'parallelDist', 'stats'. latter always available, others must installed beforehand. ordered fastest slowest. requested package installed, fastest amongst available ones picked. See Note details. verbose Print messages. Set FALSE disable ... additional parameters pass distance computation functions integration name integration score batch.var name column batch variable. (must object metadata). Required ScoreASWBatch. per.cell.var whether compute silhouette coefficients batch variable cell-type separately (default behaviour). Setting FALSE causes silhouette coefficients computed whole data directly.","code":""},{"path":"https://fspecque.github.io/test/reference/score-asw.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Score an embedding or a count matrix with the average silhouette width — score-asw","text":"ScoreASW ScoreASWBatch: single float 0 1, corresponding scaled average silhouette score. AddScoreASW AddScoreASWBatch:  updated Seurat object ASW score(s) set integration.","code":""},{"path":"https://fspecque.github.io/test/reference/score-asw.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Score an embedding or a count matrix with the average silhouette width — score-asw","text":"ScoreASW: Given matrix (reduction dimension layer), cell--cell distance matrix \\(D\\) computed. , silhouette width \\(s()\\) calculated cell \\(\\) label \\(c \\L\\) (\\(L\\) set possible cell type labels). , mean \\(s()\\) computed (.e. ASW) scaled 0 1: $$\\displaystyle ASW = \\frac{1}{\\left| L \\right|} \\times \\sum_{}{s()} \\\\[10pt] score = \\frac{ASW + 1}{2}$$ ScoreAWSBatch: default parameters (per.cell.var = TRUE) correspond original score Luecken M.D. et al., 2022. computed follow: cell type label \\(c\\) among set labels \\(L\\), cell--cell matrix distance \\(D_c\\) computed cells \\(\\) label \\(c\\). cell's silhouette width \\(s()\\) calculated according batch variable transformed close 1 absolute value close 0. average silhouette width \\(ASW_c\\) computed per cell type label \\(c \\L\\) mean correspond final score: $$\\displaystyle ASW_c = \\frac{1}{\\left| c \\right|} \\times \\sum_{\\c}{1 - \\left| s() \\right|} \\\\[10pt] score = \\frac{1}{\\left| L \\right|} \\times \\sum_{c \\L}{ASW_c}$$ per.cell.var = FALSE, \\(ASW\\) computed cells (just like ScoreASW batch variable), scaled averaged similarly: $$\\displaystyle score = ASW = \\frac{1}{N} \\times \\sum_{=1}^{N}{1 - \\left| s() \\right|}$$ \\(N\\) total number cells","code":""},{"path":"https://fspecque.github.io/test/reference/score-asw.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Score an embedding or a count matrix with the average silhouette width — score-asw","text":"scores adaptation (cell-type) ASW batch ASW described Luecken M.D. et al., 2022. Hamming distance supported parallelDist package, distances can compute euclidean related distances (cosine angular). Angular distances actually refereed 'cosine' FindNeighbors() (annoy.metric), hence called 'angular' . Actual cosine dissimilarity-derived distances returned metric = 'cosine'. Internally, angular distances computed euclidean distances \\(L^2\\) norm. cosine distances transformed : $$\\displaystyle D_{cosine} = \\frac{D_{angular}^2}{2}$$","code":""},{"path":"https://fspecque.github.io/test/reference/score-asw.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Score an embedding or a count matrix with the average silhouette width — score-asw","text":"Luecken, M. D., Büttner, M., Chaichoompu, K., Danese, ., Interlandi, M., Mueller, M. F., Strobl, D. C., Zappia, L., Dugas, M., Colomé-Tatché, M. & Theis, F. J. Benchmarking atlas-level data integration single-cell genomics. Nat Methods 19, 41–50 (2021). DOI","code":""},{"path":[]},{"path":"https://fspecque.github.io/test/reference/score-cc.html","id":null,"dir":"Reference","previous_headings":"","what":"Score a corrected or uncorrected PCA to estimate the contribution of S and G2M scores to variance — ScoreRegressPC.CellCycle","title":"Score a corrected or uncorrected PCA to estimate the contribution of S and G2M scores to variance — ScoreRegressPC.CellCycle","text":"Linearly regresses S G2M scores predict principal components. resulting R2 weighted dimension's contribution variance. Cell cycles scores PCAs computed batch independently.","code":""},{"path":"https://fspecque.github.io/test/reference/score-cc.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Score a corrected or uncorrected PCA to estimate the contribution of S and G2M scores to variance — ScoreRegressPC.CellCycle","text":"","code":"ScoreRegressPC.CellCycle(   object,   batch.var = NULL,   what = NULL,   dims.use = NULL,   npcs = 50L,   s.var = \"S.Score\",   g2m.var = \"G2M.Score\",   compute.cc = TRUE,   s.features = NULL,   g2m.features = NULL,   assay = NULL,   weight.by = c(\"var\", \"stdev\"),   adj.r2 = FALSE,   approx = FALSE )  AddScoreRegressPC.CellCycle(   object,   integration,   batch.var = NULL,   what = NULL,   dims.use = NULL,   npcs = 50L,   s.var = \"S.Score\",   g2m.var = \"G2M.Score\",   compute.cc = TRUE,   s.features = NULL,   g2m.features = NULL,   assay = NULL,   weight.by = c(\"var\", \"stdev\"),   adj.r2 = FALSE,   approx = FALSE )"},{"path":"https://fspecque.github.io/test/reference/score-cc.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Score a corrected or uncorrected PCA to estimate the contribution of S and G2M scores to variance — ScoreRegressPC.CellCycle","text":"object Seurat object batch.var name batch variable (must object metadata) slot Seurat score. Can layer reduction. dims.use dimensions consider. dimensions used default npcs Total Number PCs compute store (50 default) s.var name S phase score variable (must object metadata) g2m.var name G2M phase score variable (must object metadata) compute.cc whether (re-)compute cell cycle scores. TRUE (default), unless run CellCycleScoringPerBatch beforehand cell cycles scores expected computed per batch s.features vector features associated S phase g2m.features vector features associated G2M phase assay assay use. Passed Seurat automatically construct batch.var provided. Useless otherwise weight.one 'var' (default) 'stdev' (standing variance standard deviation respectively). Use variance standard deviation explained principal components weight PC's score. adj.r2 Whether use adjusted R2 instead raw R2 approx Use truncated singular value decomposition approximate PCA integration name integration score","code":""},{"path":"https://fspecque.github.io/test/reference/score-cc.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Score a corrected or uncorrected PCA to estimate the contribution of S and G2M scores to variance — ScoreRegressPC.CellCycle","text":"ScoreRegressPC.CellCycle: 2-columns data frame batch variable first one corresponding score second one. many rows batches. AddScoreRegressPC.CellCycle: updated Seurat object cell cycle conservation score set integration.","code":""},{"path":"https://fspecque.github.io/test/reference/score-cc.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Score a corrected or uncorrected PCA to estimate the contribution of S and G2M scores to variance — ScoreRegressPC.CellCycle","text":"linear regression $$PC_i = S_{score} + G2M_{score}$$ score computed follow : $$\\sum_{=1}^{p} \\left ( R^2_i * V_i \\right )$$ PCA p dimensions, \\(PC_i\\) principal component , \\(R^2_i\\) R squared coefficient linear regression dimension . \\(V_i\\) proportion variance explained \\(PC_i\\).","code":""},{"path":"https://fspecque.github.io/test/reference/score-cc.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Score a corrected or uncorrected PCA to estimate the contribution of S and G2M scores to variance — ScoreRegressPC.CellCycle","text":"score adaptation principal component regression (PCR) score Luecken M.D. et al., 2022.","code":""},{"path":"https://fspecque.github.io/test/reference/score-cc.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Score a corrected or uncorrected PCA to estimate the contribution of S and G2M scores to variance — ScoreRegressPC.CellCycle","text":"Luecken, M. D., Büttner, M., Chaichoompu, K., Danese, ., Interlandi, M., Mueller, M. F., Strobl, D. C., Zappia, L., Dugas, M., Colomé-Tatché, M. & Theis, F. J. Benchmarking atlas-level data integration single-cell genomics. Nat Methods 19, 41–50 (2021). DOI","code":""},{"path":[]},{"path":"https://fspecque.github.io/test/reference/score-cc.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Score a corrected or uncorrected PCA to estimate the contribution of S and G2M scores to variance — ScoreRegressPC.CellCycle","text":"","code":"if (FALSE) { # \\dontrun{ obj <- SeuratData::LoadData(\"pbmcsca\") obj[[\"RNA\"]] <- split(obj[[\"RNA\"]], f = obj$Method) obj <- NormalizeData(obj) obj <- FindVariableFeatures(obj) obj <- ScaleData(obj) obj <- RunPCA(obj)  score.cc.r2 <- ScoreRegressPC.CellCycle(obj, \"Method\", \"pca\", dim.use = 1:30) score.cc.adj.r2 <- ScoreRegressPC.CellCycle(obj, \"Method\", \"pca\", dim.use = 1:30, adj.r2 = TRUE)  score.cc.r2        # ~ 0.0249 score.cc.adj.r2    # ~ 0.0249 } # }"},{"path":"https://fspecque.github.io/test/reference/score-connectivity.html","id":null,"dir":"Reference","previous_headings":"","what":"Score a knn graph based on cell-type label connectivity — ScoreConnectivity","title":"Score a knn graph based on cell-type label connectivity — ScoreConnectivity","text":"Compute scores based connectivity cells sharing label. score can calculated two fashions, either quantifying connectivity largest subgraph cell label (identical score used Luecken M.D. et al., 2022), directly whole graph.","code":""},{"path":"https://fspecque.github.io/test/reference/score-connectivity.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Score a knn graph based on cell-type label connectivity — ScoreConnectivity","text":"","code":"ScoreConnectivity(   object,   graph.name,   cell.var,   do.symmetrize = TRUE,   per.component = TRUE,   count.self = FALSE,   weight.by.ncells = FALSE )  AddScoreConnectivity(   object,   integration,   graph.name,   cell.var,   do.symmetrize = TRUE,   per.component = TRUE,   count.self = FALSE,   weight.by.ncells = FALSE )"},{"path":"https://fspecque.github.io/test/reference/score-connectivity.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Score a knn graph based on cell-type label connectivity — ScoreConnectivity","text":"object Seurat object graph.name name knn graph score. cell.var name  cell variable (must object metadata). .symmetrize whether symmetrize knn graph. Set toFALSE disable (recommended, see Details) per.component whether use score Luecken M.D. et al., 2022. TRUE default. See Details. count.self whether account loops (.e. cells connected ). FALSE default weight..ncells whether weight connectivity-derived scores computed cell type label relative proportion number cells. default (FALSE), overall score computed mean scores computed per label. Ignored per.component = TRUE integration name integration score","code":""},{"path":"https://fspecque.github.io/test/reference/score-connectivity.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Score a knn graph based on cell-type label connectivity — ScoreConnectivity","text":"ScoreConnectivity: single float 0 1, corresponding connectivity score. AddScoreConnectivity: updated Seurat object Graph connectivity score set integration.","code":""},{"path":"https://fspecque.github.io/test/reference/score-connectivity.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Score a knn graph based on cell-type label connectivity — ScoreConnectivity","text":"default parameters (per.component = TRUE, count.self = FALSE) correspond original score Luecken M.D. et al., 2022. computed follow: cell type label \\(c\\) among set labels \\(L\\), sub graph \\(subG_c\\) exclusively composed cells \\(c\\) extracted full graph \\(G\\). , size (.e. number cells, hence vertices \\(V\\)) largest connected component divided size \\(subG_c\\). , mean sub graphs' scores computed: $$ratio_c = \\frac{max(\\left|V(CC(subG_c))\\right|)}{\\left|V(subG_c)\\right|}$$ $$score = \\frac{1}{\\left| L \\right|}\\sum_{c \\L} ratio_c$$ per.component = FALSE, connectivity computed full graph \\(G\\). consider set labels \\(L\\), \\(c \\L\\) \\(L\\prime = L \\setminus \\{c\\}\\). also denote edges cells \\(\\\\{c\\}\\) \\(E_c = E_{c \\c}(G)\\) edges connecting cells \\(\\\\{c\\}\\) cells \\(\\L\\prime\\) \\(E_c^{\\prime} = E_{c \\L\\prime}(G)\\). weight..ncells = TRUE, score computed follow: $$score = \\sum_{c \\L} \\left( \\frac{\\left| V(subG_c) \\right|}{\\left| V(G) \\right|} \\times \\frac{\\left| E_c \\right|}{\\left| E_c^\\prime \\right| + \\left| E_c \\right|}\\right)$$ weight..ncells = FALSE, score mean ratio edges: $$score = \\frac{1}{\\left| L \\right|}\\sum_{c \\L} \\frac{\\left| E_c \\right|}{\\left| E_c^\\prime \\right| + \\left| E_c \\right|}$$ either case, recommended keep .symmetrize = TRUE.","code":""},{"path":"https://fspecque.github.io/test/reference/score-connectivity.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Score a knn graph based on cell-type label connectivity — ScoreConnectivity","text":"score adaptation graph connectivity score described Luecken M.D. et al., 2022.","code":""},{"path":"https://fspecque.github.io/test/reference/score-connectivity.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Score a knn graph based on cell-type label connectivity — ScoreConnectivity","text":"Luecken, M. D., Büttner, M., Chaichoompu, K., Danese, ., Interlandi, M., Mueller, M. F., Strobl, D. C., Zappia, L., Dugas, M., Colomé-Tatché, M. & Theis, F. J. Benchmarking atlas-level data integration single-cell genomics. Nat Methods 19, 41–50 (2021). DOI","code":""},{"path":[]},{"path":"https://fspecque.github.io/test/reference/score-densityPC.html","id":null,"dir":"Reference","previous_headings":"","what":"Score a corrected or uncorrected PCA to estimate batch mixing — ScoreDensityPC","title":"Score a corrected or uncorrected PCA to estimate batch mixing — ScoreDensityPC","text":"batch-wise kernel density estimate computed dimension PCA. , global area shared kernels calculated divided reference area (see Arguments Details) proxy batch mixing. Finally, aforementioned proportions weighted dimension's contribution variance.","code":""},{"path":"https://fspecque.github.io/test/reference/score-densityPC.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Score a corrected or uncorrected PCA to estimate batch mixing — ScoreDensityPC","text":"","code":"ScoreDensityPC(   object,   batch.var = NULL,   reduction = \"pca\",   dims = NULL,   use.union = TRUE,   bw.join = mean,   bw.kernel = c(\"nrd0\", \"nrd\", \"ucv\", \"bcv\", \"sj\"),   weight.by = c(\"var\", \"stdev\"),   assay = NULL,   layer = NULL )  AddScoreDensityPC(   object,   integration,   batch.var = NULL,   reduction = \"pca\",   dims = NULL,   use.union = TRUE,   bw.join = mean,   bw.kernel = c(\"nrd0\", \"nrd\", \"ucv\", \"bcv\", \"sj\"),   weight.by = c(\"var\", \"stdev\"),   assay = NULL,   layer = NULL )"},{"path":"https://fspecque.github.io/test/reference/score-densityPC.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Score a corrected or uncorrected PCA to estimate batch mixing — ScoreDensityPC","text":"object Seurat object batch.var name batch variable (must object metadata) reduction name reduction score dims dimensions consider. dimensions used default use.union Whether use union densities (constructs fake density pmax). alternative use density kernels sum bw.join function pick joint bandwidth. default use mean(). can also chose median instance. want use distinct bandwidth batch, just set bw.join = c (recommended) bw.kernel Bandwidth selector use Gaussian kernel density estimation. One 'nrd0', 'nrd', 'ucv','bcv' 'sj' (see bandwidths). nrd0 default weight.one 'var' (default) 'stdev' (standing variance standard deviation respectively). Use variance standard deviation explained principal components weight PC's score. assay assay use. Passed Seurat automatically construct batch.var provided. Useless otherwise layer layer use. Passed Seurat automatically construct batch.var provided. Useless otherwise integration name integration score","code":""},{"path":"https://fspecque.github.io/test/reference/score-densityPC.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Score a corrected or uncorrected PCA to estimate batch mixing — ScoreDensityPC","text":"ScoreDensityPC: single float corresponding score given reduction AddScoreDensityPC: updated Seurat object density PCA score set integration.","code":""},{"path":"https://fspecque.github.io/test/reference/score-densityPC.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Score a corrected or uncorrected PCA to estimate batch mixing — ScoreDensityPC","text":"score computed follow : $$\\sum_{=1}^{p} \\left ( \\cfrac{ \\bigcup_{b=1}^n D_{bi} }{ Ref_i } * V_i \\right )$$ PCA p dimensions n batchs. \\(D_{bi}\\) vector density batch b dimension . \\(V_i\\) proportion variance explained \\(PC_i\\). \\(Ref = \\bigcap_{=1}^n D_{bi}\\) \\(Ref = \\sum_{=1}^n D_{bi}\\) use.union TRUE FALSE respectively, given dimension \\(\\). use.union = FALSE tends result lower score since reference sum kernel densities instead maximum","code":""},{"path":"https://fspecque.github.io/test/reference/score-densityPC.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Score a corrected or uncorrected PCA to estimate batch mixing — ScoreDensityPC","text":"score adaptation principal component regression (PCR) score Luecken M.D. et al., 2022.","code":""},{"path":"https://fspecque.github.io/test/reference/score-densityPC.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Score a corrected or uncorrected PCA to estimate batch mixing — ScoreDensityPC","text":"Luecken, M. D., Büttner, M., Chaichoompu, K., Danese, ., Interlandi, M., Mueller, M. F., Strobl, D. C., Zappia, L., Dugas, M., Colomé-Tatché, M. & Theis, F. J. Benchmarking atlas-level data integration single-cell genomics. Nat Methods 19, 41–50 (2021). DOI","code":""},{"path":[]},{"path":"https://fspecque.github.io/test/reference/score-densityPC.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Score a corrected or uncorrected PCA to estimate batch mixing — ScoreDensityPC","text":"","code":"if (FALSE) { # \\dontrun{ obj <- SeuratData::LoadData(\"pbmcsca\") obj[[\"RNA\"]] <- split(obj[[\"RNA\"]], f = obj$Method) obj <- NormalizeData(obj) obj <- FindVariableFeatures(obj) obj <- ScaleData(obj) obj <- RunPCA(obj)  score.union <- ScoreDensityPC(obj, \"Method\", \"pca\", dim = 1:30) score.sum <- ScoreDensityPC(obj, \"Method\", \"pca\", dim = 1:30, use.union = FALSE)  score.union   # ~ 0.1511 score.sum     # ~ 0.0319 } # }"},{"path":"https://fspecque.github.io/test/reference/score-kbet.html","id":null,"dir":"Reference","previous_headings":"","what":"Score an embedding or a knn graph with the kBET test — ScoreKBET","title":"Score an embedding or a knn graph with the kBET test — ScoreKBET","text":"Compute scores based k-nearest neighbour batch effect test (kBET). Accepts DimReduc instance graph object (Graph Neighbor) provided contains distances connectivities. '' DimReduc object, knn graph computed k = 50. , ('' Graph Neighbor object), connectivities derives 50 nearest neighbours distances. Finally, kBET test computed cell-type label provided cell.var. kBET measures local batch label distribution similar global one. result kBET average test rejection rate (0 1). closest zero, less bias attributable batch effect.","code":""},{"path":"https://fspecque.github.io/test/reference/score-kbet.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Score an embedding or a knn graph with the kBET test — ScoreKBET","text":"","code":"ScoreKBET(   object,   batch.var,   cell.var,   what,   graph.type = c(\"distances\", \"connectivities\"),   seed.use = 42L,   verbose = TRUE,   assay = NULL,   layer = NULL )  AddScoreKBET(   object,   integration,   batch.var,   cell.var,   what,   graph.type = c(\"distances\", \"connectivities\"),   seed.use = 42L,   verbose = TRUE,   assay = NULL,   layer = NULL )"},{"path":"https://fspecque.github.io/test/reference/score-kbet.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Score an embedding or a knn graph with the kBET test — ScoreKBET","text":"object Seurat object batch.var name batch variable (must object metadata) cell.var name column cell type label variable (must object metadata). NULL passed, kBET score computed cells . name dimension reduction Graph/Neighbor object score. Must Seurat object. graph.type one 'distances' (default) 'connectivities', indicate type graph dimension reduction. seed.use value seed obtain reproducible results. NULL disables use seed verbose whether print progress messages assay assay use. Passed Seurat automatically construct batch.var provided (DefaultAssay() used default). Useless otherwise layer layer use. Passed Seurat automatically construct batch.var provided. Useless otherwise integration name integration score","code":""},{"path":"https://fspecque.github.io/test/reference/score-kbet.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Score an embedding or a knn graph with the kBET test — ScoreKBET","text":"ScoreKBET: list one element per cell.var. named numeric vector kBET score (floats 0 1), one per cell-label. AddScoreKBET:  updated Seurat object mean kBET score(s) set integration.","code":""},{"path":"https://fspecque.github.io/test/reference/score-kbet.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Score an embedding or a knn graph with the kBET test — ScoreKBET","text":"Büttner, M., Miao, Z., Wolf, F. ., Teichmann, S. . & Theis, F. J. test metric assessing single-cell RNA-seq batch correction. Nat Methods 16, 43–49 (2018). DOI Luecken, M. D., Büttner, M., Chaichoompu, K., Danese, ., Interlandi, M., Mueller, M. F., Strobl, D. C., Zappia, L., Dugas, M., Colomé-Tatché, M. & Theis, F. J. Benchmarking atlas-level data integration single-cell genomics. Nat Methods 19, 41–50 (2021). DOI","code":""},{"path":"https://fspecque.github.io/test/reference/score-lisi.html","id":null,"dir":"Reference","previous_headings":"","what":"Score a dimensionality reduction embedding or knn graph using the Local Inverse Simpson Index — AddScoreLISI","title":"Score a dimensionality reduction embedding or knn graph using the Local Inverse Simpson Index — AddScoreLISI","text":"Compute Local Inverse Simpson's Index (LISI) estimate batch mixing cell type mixing (iLISI cLISI respectively according Luecken M.D. et al., 2022). AddScoreLISI returns updated Seurat object, ScoreLISI outputs raw LISI scores cell","code":""},{"path":"https://fspecque.github.io/test/reference/score-lisi.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Score a dimensionality reduction embedding or knn graph using the Local Inverse Simpson Index — AddScoreLISI","text":"","code":"AddScoreLISI(   object,   integration,   batch.var = NULL,   cell.var = NULL,   reduction,   dims = NULL,   graph.name,   graph.type = c(\"distances\", \"connectivities\"),   do.symmetrize = TRUE,   save.graph = TRUE,   new.graph = NULL,   perplexity = 30,   tol = 1e-05,   do.scale = TRUE,   largest.component.only = FALSE,   assay = NULL,   verbose = TRUE,   ... )  ScoreLISI(   object,   batch.var = NULL,   cell.var = NULL,   reduction,   dims = NULL,   graph.name,   graph.type = c(\"distances\", \"connectivities\"),   do.symmetrize = TRUE,   return.graph = FALSE,   perplexity = 30,   tol = 1e-05,   largest.component.only = FALSE,   assay = NULL,   verbose = TRUE,   ... )"},{"path":"https://fspecque.github.io/test/reference/score-lisi.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Score a dimensionality reduction embedding or knn graph using the Local Inverse Simpson Index — AddScoreLISI","text":"object Seurat object integration name integration score batch.var name batch variable (must object metadata). Can omitted cell.var NULL cell.var name  cell variable (must object metadata). Can omitted batch.var NULL reduction name reduction score. Arguments reduction graph.name mutually exclusive dims dimensions reduction consider. dimensions used default. Ignored scoring graph graph.name name knn graph score. Arguments reduction graph.name mutually exclusive graph.type one 'distances' 'connectivities' (supported yet). Ignored scoring cell embedding .symmetrize whether symmetrize knn graphs. Set toFALSE disable (recommended, especially scoring knn graph directly. See Details) save.graph whether save graph used compute LISI score(s) Seurat object new.graph name graph used compute LISI score(s). new.graph = NULL (default), name constructed depending input arguments. Ignored save.graph = FALSE perplexity third number cell's neighbours. value perplexity number neighbours (*3) discrepant, graph adapted. Multiple scores varying values perplexity comparable, hence recommended use value integration score. tol Stop computation local Simpson's index converges tolerance. .scale whether scale output LISI values 0 1. largest.component.whether compute scores largest component sufficiently large components (default) assay name assay reference output Graph object ( save.graph = TRUE) verbose whether print progress messages ... Additional parameters pass methods (see Details). return.graph whether return graph used compute LISI score(s)","code":""},{"path":"https://fspecque.github.io/test/reference/score-lisi.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Score a dimensionality reduction embedding or knn graph using the Local Inverse Simpson Index — AddScoreLISI","text":"ScoreLISI: data frame cell's raw LISI score, list containing aforementioned data frame graph used compute (return.graph = TRUE). AddScoreLISI: updated Seurat object, cell-wise LISI scores meta data (identical ScoreLISI's output), global scores misc new Graph object save.graph = TRUE.","code":""},{"path":"https://fspecque.github.io/test/reference/score-lisi.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Score a dimensionality reduction embedding or knn graph using the Local Inverse Simpson Index — AddScoreLISI","text":"scoring reduction, knn graph enough neighbours per cell computed. .symmetrize = TRUE, graph symmetrized k best neighbours kept. scoring knn graph, graph expanded Dijkstra's algorithm reach enough neighbours per cell. .symmetrize = TRUE, graph symmetrized beforehand. Note .symmetrize = FALSE, Dijkstra's algorithm applied asymmetric distance matrix, components computed. component symmetrized Dijkstra's algorithm computed . Indeed, guarantee cells' number neighbours preserved decomposing directed graph. Hence, .symmetrize = FALSE graph input, graph considered directed find components. either case, recommended keep .symmetrize = TRUE. possible additional parameters, see FindNeighbors (inputting reduction) ExpandNeighbours (inputting knn graph)","code":""},{"path":"https://fspecque.github.io/test/reference/score-lisi.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Score a dimensionality reduction embedding or knn graph using the Local Inverse Simpson Index — AddScoreLISI","text":"score adaptation LISI score described Korsunsky . et al., 2019 also used Luecken M.D. et al., 2022.","code":""},{"path":"https://fspecque.github.io/test/reference/score-lisi.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Score a dimensionality reduction embedding or knn graph using the Local Inverse Simpson Index — AddScoreLISI","text":"Korsunsky, ., Millard, N., Fan, J., Slowikowski, K., Zhang, F., Wei, K., Baglaenko, Y., Brenner, M., Loh, P. & Raychaudhuri, S. Fast, sensitive accurate integration single-cell data Harmony. Nat Methods 16, 1289–1296 (2019). DOI Luecken, M. D., Büttner, M., Chaichoompu, K., Danese, ., Interlandi, M., Mueller, M. F., Strobl, D. C., Zappia, L., Dugas, M., Colomé-Tatché, M. & Theis, F. J. Benchmarking atlas-level data integration single-cell genomics. Nat Methods 19, 41–50 (2021). DOI","code":""},{"path":[]},{"path":"https://fspecque.github.io/test/reference/score-nmi.html","id":null,"dir":"Reference","previous_headings":"","what":"Score a clustering result with normalised mutual information — ScoreNMI","title":"Score a clustering result with normalised mutual information — ScoreNMI","text":"Compute score based normalised mutual information clustering result one cell type label variable(s). 0 1 reflect absence mutual information perfect correlation respectively.","code":""},{"path":"https://fspecque.github.io/test/reference/score-nmi.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Score a clustering result with normalised mutual information — ScoreNMI","text":"","code":"ScoreNMI(   object,   cell.var,   clust.var = \"seurat_clusters\",   average.entropy = c(\"mean\", \"geom\", \"min\", \"max\") )  AddScoreNMI(   object,   integration,   cell.var,   clust.var = \"seurat_clusters\",   average.entropy = c(\"mean\", \"geom\", \"min\", \"max\") )"},{"path":"https://fspecque.github.io/test/reference/score-nmi.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Score a clustering result with normalised mutual information — ScoreNMI","text":"object Seurat object cell.var name(s) column(s) cell type label variable (must object metadata). Multiple column names accepted clust.var name column cluster id assignment cell (must object metadata). one column name accepted average.entropy method compute value normalisation denominator variable's entropy. one 'mean', 'geom', 'min' 'max', namely 'arithmetic mean ', 'geometric mean ', 'minimum' 'maximum' entropy respectively. integration name integration score","code":""},{"path":"https://fspecque.github.io/test/reference/score-nmi.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Score a clustering result with normalised mutual information — ScoreNMI","text":"ScoreNMI: named array many values common strings cell.var column names object's metadata. Names cell.var values NMI scores. AddScoreNMI: updated Seurat object NMI score(s) set integration.","code":""},{"path":"https://fspecque.github.io/test/reference/score-nmi.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Score a clustering result with normalised mutual information — ScoreNMI","text":"Considering \\(N\\)-cells dataset, \\(\\left|L_i\\right|\\) number cells labelled cell type \\(L_i\\) \\(\\left|C_i\\right|\\) number cells cluster \\(C_i\\). discrete mutual information \\(MI\\) approximation given : $$\\displaystyle MI(L, C) = \\sum_{=1}^{\\left|L\\right|}\\sum_{j=1}^{\\left|C\\right|} \\left( \\frac{\\left|L_i \\cap C_j\\right|}{N} \\times log \\left(\\frac{N \\times \\left|L_i \\cap C_j\\right|}{\\left|L_i\\right| \\left|C_j\\right|} \\right) \\right)$$ , \\(MI\\) normalised (scaled) denominator, computed applying function \\(f\\) variables' entropies (\\(H\\)). \\(f\\) can either arithmetic mean, geometric mean, maximum minimum entropies. $$\\displaystyle NMI(L, C) = \\frac{MI(L, C)}{f(H(L), H(C))}$$","code":""},{"path":"https://fspecque.github.io/test/reference/score-nmi.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Score a clustering result with normalised mutual information — ScoreNMI","text":"metric symmetric. Switching cell.var clust.var return value.","code":""},{"path":"https://fspecque.github.io/test/reference/score-nmi.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Score a clustering result with normalised mutual information — ScoreNMI","text":"Luecken, M. D., Büttner, M., Chaichoompu, K., Danese, ., Interlandi, M., Mueller, M. F., Strobl, D. C., Zappia, L., Dugas, M., Colomé-Tatché, M. & Theis, F. J. Benchmarking atlas-level data integration single-cell genomics. Nat Methods 19, 41–50 (2021). DOI","code":""},{"path":"https://fspecque.github.io/test/reference/score-regressPC.html","id":null,"dir":"Reference","previous_headings":"","what":"Score a corrected or uncorrected PCA to estimate batch mixing — ScoreRegressPC","title":"Score a corrected or uncorrected PCA to estimate batch mixing — ScoreRegressPC","text":"Linearly regresses principal components batch variable proxy estimate batch mixing. resulting R2 weighted dimension's contribution variance.","code":""},{"path":"https://fspecque.github.io/test/reference/score-regressPC.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Score a corrected or uncorrected PCA to estimate batch mixing — ScoreRegressPC","text":"","code":"ScoreRegressPC(   object,   batch.var = NULL,   reduction = \"pca\",   dims = NULL,   adj.r2 = FALSE,   weight.by = c(\"var\", \"stdev\"),   assay = NULL,   layer = NULL )  AddScoreRegressPC(   object,   integration,   batch.var = NULL,   reduction = \"pca\",   dims = NULL,   adj.r2 = FALSE,   weight.by = c(\"var\", \"stdev\"),   assay = NULL,   layer = NULL )"},{"path":"https://fspecque.github.io/test/reference/score-regressPC.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Score a corrected or uncorrected PCA to estimate batch mixing — ScoreRegressPC","text":"object Seurat object batch.var name batch variable (must object metadata) reduction name reduction score dims dimensions consider. dimensions used default adj.r2 Whether use adjusted R2 instead raw R2 weight.one 'var' (default) 'stdev' (standing variance standard deviation respectively). Use variance standard deviation explained principal components weight PC's score. assay assay use. Passed Seurat automatically construct batch.var provided. Useless otherwise layer layer use. Passed Seurat automatically construct batch.var provided. Useless otherwise integration name integration score","code":""},{"path":"https://fspecque.github.io/test/reference/score-regressPC.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Score a corrected or uncorrected PCA to estimate batch mixing — ScoreRegressPC","text":"ScoreRegressPC: single float corresponding score given reduction AddScoreRegressPC: updated Seurat object regression PCA score set integration.","code":""},{"path":"https://fspecque.github.io/test/reference/score-regressPC.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Score a corrected or uncorrected PCA to estimate batch mixing — ScoreRegressPC","text":"linear regression $$PC_i = Batch$$ score computed follow : $$\\sum_{=1}^{p} \\left ( R^2_i * V_i \\right )$$ PCA p dimensions, \\(PC_i\\) principal component , \\(R^2_i\\) R squared coefficient linear regression dimension . \\(V_i\\) proportion variance explained \\(PC_i\\).","code":""},{"path":"https://fspecque.github.io/test/reference/score-regressPC.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Score a corrected or uncorrected PCA to estimate batch mixing — ScoreRegressPC","text":"score adaptation principal component regression (PCR) score Luecken M.D. et al., 2022.","code":""},{"path":"https://fspecque.github.io/test/reference/score-regressPC.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Score a corrected or uncorrected PCA to estimate batch mixing — ScoreRegressPC","text":"Luecken, M. D., Büttner, M., Chaichoompu, K., Danese, ., Interlandi, M., Mueller, M. F., Strobl, D. C., Zappia, L., Dugas, M., Colomé-Tatché, M. & Theis, F. J. Benchmarking atlas-level data integration single-cell genomics. Nat Methods 19, 41–50 (2021). DOI","code":""},{"path":[]},{"path":"https://fspecque.github.io/test/reference/score-regressPC.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Score a corrected or uncorrected PCA to estimate batch mixing — ScoreRegressPC","text":"","code":"if (FALSE) { # \\dontrun{ obj <- SeuratData::LoadData(\"pbmcsca\") obj[[\"RNA\"]] <- split(obj[[\"RNA\"]], f = obj$Method) obj <- NormalizeData(obj) obj <- FindVariableFeatures(obj) obj <- ScaleData(obj) obj <- RunPCA(obj)  score.r2 <- ScoreRegressPC(obj, \"Method\", \"pca\", dim = 1:30) score.adj.r2 <- ScoreRegressPC(obj, \"Method\", \"pca\", dim = 1:30, adj.r2 = TRUE)  score.r2    # ~ 0.1147 score.adj.r2     # ~ 0.1145 } # }"},{"path":"https://fspecque.github.io/test/reference/trVAEIntegration.html","id":null,"dir":"Reference","previous_headings":"","what":"Run trVAE on Seurat's Assay5 object through IntegrateLayers — trVAEIntegration","title":"Run trVAE on Seurat's Assay5 object through IntegrateLayers — trVAEIntegration","text":"wrapper run trVAE multi-layered Seurat V5 object. Requires conda environment scArches necessary dependencies Recommendations: use raw counts (except recon.loss = \"mse\") features (features = Features(object), layers = \"counts\", scale.layer = NULL).","code":""},{"path":"https://fspecque.github.io/test/reference/trVAEIntegration.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Run trVAE on Seurat's Assay5 object through IntegrateLayers — trVAEIntegration","text":"","code":"trVAEIntegration(   object,   orig = NULL,   groups = NULL,   groups.name = NULL,   surgery.name = NULL,   surgery.sort = TRUE,   features = NULL,   layers = ifelse(recon.loss == \"mse\", \"data\", \"counts\"),   scale.layer = \"scale.data\",   conda_env = NULL,   new.reduction = \"integrated.trVAE\",   reduction.key = \"trVAElatent_\",   torch.intraop.threads = 4L,   torch.interop.threads = NULL,   model.save.dir = NULL,   ndims.out = 10L,   recon.loss = c(\"nb\", \"zinb\", \"mse\"),   hidden_layer_sizes = c(256L, 64L),   dr_rate = 0.05,   use_mmd = TRUE,   mmd_on = c(\"z\", \"y\"),   mmd_boundary = NULL,   beta = 1,   use_bn = FALSE,   use_ln = TRUE,   n_epochs = 400L,   lr = 0.001,   eps = 0.01,   hide.py.warn = T,   seed.use = 42L,   verbose = TRUE,   ... )"},{"path":"https://fspecque.github.io/test/reference/trVAEIntegration.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Run trVAE on Seurat's Assay5 object through IntegrateLayers — trVAEIntegration","text":"object Seurat object (Assay5 object called IntegrateLayers) orig DimReduc object. set directly called IntegrateLayers, use orig.reduction argument instead groups named data frame grouping information. Can also contain surgery groups perform surgery integration. groups.name Column name groups data frame stores grouping information. groups.name = NULL, first column used surgery.name Column name groups data frame stores surgery information. surgery.name = NULL, one shot integration performed surgery.sort change order surgery groups integrated. default (surgery.sort = TRUE), surgery groups ordered name. FALSE, group integrated order first occurrence column surgery.name features Vector feature names input integration method. features = NULL (default), VariableFeatures used. pass features, use output Features() layers Name layers use integration scale.layer Name scaled layer Assay conda_env Path conda environment run trVAE (also contain scipy python module).  default, uses conda environment registered trVAE conda environment manager new.reduction Name new integrated dimensional reduction reduction.key Key new integrated dimensional reduction torch.intraop.threads Number intra-op threads available torch training CPU instead GPU. Set via torch.set_num_threads(). torch.interop.threads Number intra-op threads available torch training CPU instead GPU. Set via torch.set_num_interop_threads(). Can changed , first call. model.save.dir Path directory save model(s) . Uses TRVAE.save(). save anndata. model.save.dir = NULL (default) disables saving model(s). ndims.Number dimensions new.reduction output. Corresponds latent_dim argument original API TRVAE scArches recon.loss Definition Reconstruction-Loss-Method. One 'mse', 'nb' 'zinb' (hence mean squared error, negative binomial zero-inflated negative binomial respectively). Recommended set layer = \"data\" 'mse' (layer = \"counts\" (zi)nb) hidden_layer_sizes Hidden layer sizes encoder network dr_rate Dropout rate applied layers. dr_rate = 0 disables dropout. use_mmd Whether additional MMD loss calculated latent dim. (see next argument) mmd_on Choose layer MMD loss calculated . One 'z' latent dim 'y' first decoder layer. applies use_mmd = TRUE mmd_boundary many groups MMD loss calculated . mmd_boundary = NULL (default), MMD calculated groups. applies use_mmd = TRUE beta Scaling factor MMD loss (1 default). applies use_mmd = TRUE use_bn Whether apply batch normalization layers use_ln Whether apply layer normalization layers n_epochs Maximum number epochs train model lr Learning rate training eps torch.optim.Adam eps parameter improve numerical stability (see ) hide.py.warn Disables uninformative warnings torch seed.use integer generate reproducible outputs. Set seed.use = NULL disable verbose Print messages. Set FALSE disable ... Additional arguments passed scarches.models.TRVAE.train, TRVAE.load_query_data TRVAE.get_latent (see Details section)","code":""},{"path":"https://fspecque.github.io/test/reference/trVAEIntegration.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Run trVAE on Seurat's Assay5 object through IntegrateLayers — trVAEIntegration","text":"list containing: Without surgery groups: new DimReduc name   new.reduction (key set reduction.key) consisting   latent space model ndims.dimensions. surgery groups: one new DimReduc per surgery groups   name new.reduction_[surgery.group] (key set   reduction.key[surgery.group]) consisting latent space   corresponding models ndims.dimensions,  well 'full'   latent representation name new.reduction_[surgery1]_[surgery2]_...   key set reduction.keyFull-. called via IntegrateLayers, Seurat object new reduction /assay returned","code":""},{"path":"https://fspecque.github.io/test/reference/trVAEIntegration.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Run trVAE on Seurat's Assay5 object through IntegrateLayers — trVAEIntegration","text":"wrappers calls three four python functions reticulate. Find trVAE-specific arguments : model initiation:   scarches.models.TRVAE training:   TRVAE.train, relies   scarches.trainers.trvae.train.Trainer post-training:   scarches.models.base._base.CVAELatentsMixin.get_latent surgery initiation:   scarches.models.base._base.SurgeryMixin.load_query_data Note seed.use passed torch.manual_seed(). sufficient achieve full reproducibility, set mean = TRUE mean_var = TRUE","code":""},{"path":"https://fspecque.github.io/test/reference/trVAEIntegration.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Run trVAE on Seurat's Assay5 object through IntegrateLayers — trVAEIntegration","text":"function requires scArches package installed (along scipy)","code":""},{"path":"https://fspecque.github.io/test/reference/trVAEIntegration.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Run trVAE on Seurat's Assay5 object through IntegrateLayers — trVAEIntegration","text":"Lotfollahi, M., Naghipourfar, M., Theis, F. J. & Wolf, F. . Conditional --distribution generation unpaired data using transfer VAE. Bioinformatics 36, i610–i617 (2020). DOI Lotfollahi, M., Naghipourfar, M., Luecken, M. D., Khajavi, M., Büttner, M., Wagenstetter, M., Avsec, Ž., Gayoso, ., Yosef, N., Interlandi, M., Rybakov, S., Misharin, . V. & Theis, F. J. Mapping single-cell data reference atlases transfer learning. Nat Biotechnol 40, 121–130 (2021). DOI","code":""},{"path":[]},{"path":"https://fspecque.github.io/test/reference/trVAEIntegration.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Run trVAE on Seurat's Assay5 object through IntegrateLayers — trVAEIntegration","text":"","code":"if (FALSE) { # \\dontrun{ # Preprocessing obj <- SeuratData::LoadData(\"pbmcsca\") obj[[\"RNA\"]] <- split(obj[[\"RNA\"]], f = obj$Method) obj <- NormalizeData(obj) obj <- FindVariableFeatures(obj) obj <- ScaleData(obj) obj <- RunPCA(obj)  # After preprocessing, we integrate layers: obj <- IntegrateLayers(object = obj, method = trVAEIntegration,                        features = Features(obj), scale.layer = NULL,                        layers = 'counts', groups = obj[[]],                        groups.name = 'Method')  # To enable surgery and full reproducibility and change the recon loss method: obj <- IntegrateLayers(object = obj, method = trVAEIntegration,                        features = Features(obj), scale.layer = NULL,                        layers = 'data', groups = obj[[]],                        groups.name = 'Method', surgery.name = 'Experiment',                        mean_var = TRUE, recon.loss = 'mse') } # }"}]
